<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Websocket实时统计在线用户数</title>
    <url>/Spring-Boot/Spring%20Websocket%E5%AE%9E%E6%97%B6%E7%BB%9F%E8%AE%A1%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="GitHub源码地址"><a href="#GitHub源码地址" class="headerlink" title="GitHub源码地址"></a><a href="https://github.com/XiumingLee/MingRepository/tree/master/websocket" target="_blank" rel="noopener">GitHub源码地址</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近有个需求，需要实时统计在线的人数，由于该项目并没用到实时通信，也只有这里需要实时统计在线，没必要再搭建一套实时通信服务，所以直接整合的<code>Spring Websocket</code>。下面的<code>demo</code>是项目中的简化版，使用<code>Spring Boot</code>搭建的环境。效果如图所示：</p>
<p><img src="http://qiniu.mrain22.cn/201908241758_370.gif" alt=""></p>
<p>网上对<code>Websocket</code>的讲解有很多了，这里就不在赘述。简单粗暴，直接开干。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.56<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Websocket工具类"><a href="#Websocket工具类" class="headerlink" title="Websocket工具类"></a>Websocket工具类</h3><p>先写一个工具类，用来处理在线人数的统计以及<code>WebSocketSession</code>的管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 统计人数相关工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketCountUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量，用来记录当前在线连接数。即返回前台的人数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long onlineCount = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放普通用户ID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;String&gt; userIdSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放普通用户Session和id。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;SessionEntity&gt; usersSessionEntitySet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存放管理员Session和id。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;SessionEntity&gt; adminSessionEntitySet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线人数增加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onlineCountAdd</span><span class="params">(WebSocketSession session, String userId)</span> </span>&#123;</span><br><span class="line">        userIdSet.add(userId);</span><br><span class="line">        SessionEntity sessionEntity = <span class="keyword">new</span> SessionEntity(userId, session);</span><br><span class="line">        usersSessionEntitySet.add(sessionEntity);</span><br><span class="line">        onlineCountChangeIf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线人数减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onlineCountReduce</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        usersSessionEntitySet.forEach(sessionEntity -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (sessionEntity.getSession().getId().equals(session.getId())) &#123;</span><br><span class="line">                usersSessionEntitySet.remove(sessionEntity);</span><br><span class="line">                userIdSet.remove(sessionEntity.getUserId());</span><br><span class="line">                onlineCountChangeIf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * admin用户增加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adminSessionAdd</span><span class="params">(WebSocketSession session, String adminUserId)</span> </span>&#123;</span><br><span class="line">        SessionEntity sessionEntity = <span class="keyword">new</span> SessionEntity(adminUserId, session);</span><br><span class="line">        adminSessionEntitySet.add(sessionEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * admin用户减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adminSessionReduce</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"admin用户减少"</span>);</span><br><span class="line">        log.info(adminSessionEntitySet.toString());</span><br><span class="line">        adminSessionEntitySet.forEach(sessionEntity -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (sessionEntity.getSession().getId().equals(session.getId())) &#123;</span><br><span class="line">                adminSessionEntitySet.remove(sessionEntity);</span><br><span class="line">                log.info(adminSessionEntitySet.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向admin推送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMessageToAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adminSessionEntitySet.forEach(sessionEntity -&gt; &#123;</span><br><span class="line">            MessageEntity messageEntity = <span class="keyword">new</span> MessageEntity(<span class="string">"2"</span>, String.valueOf(getOnlineCount()));</span><br><span class="line">            String messageString = JSONObject.toJSONString(messageEntity);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sessionEntity.getSession().sendMessage(<span class="keyword">new</span> TextMessage(messageString));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.error(<span class="string">"发送信息失败--&gt;&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线人数是否改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onlineCountChangeIf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long size = Long.valueOf(userIdSet.size());</span><br><span class="line">        <span class="keyword">if</span> (onlineCount.equals(size)) &#123;</span><br><span class="line">            <span class="comment">// 在线人数没有变</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在线人数变了</span></span><br><span class="line">        onlineCount = size;</span><br><span class="line">        <span class="comment">// 向admin发送消息</span></span><br><span class="line">        setMessageToAdmin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebSocketHandler编写"><a href="#WebSocketHandler编写" class="headerlink" title="WebSocketHandler编写"></a>WebSocketHandler编写</h3><p><code>WebSocketHandler</code>是消息和生命周期事件的处理程序。下面编写了两个<code>WebSocketHandler</code>分别处理普通用户的连接和管理员的连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 普通用户登录成功后，连接websocket处理的Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConnectionHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"用户连接成功-&gt;&#123;&#125;"</span>,session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message;</span><br><span class="line">        log.warn(<span class="string">"收到消息-&gt;&#123;&#125;"</span>,textMessage);</span><br><span class="line">        MessageEntity messageEntity = JSONObject.parseObject(textMessage.getPayload(), MessageEntity.class);</span><br><span class="line">        WebSocketCountUtil.onlineCountAdd(session,messageEntity.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传输消息出错"</span>+<span class="string">"afterConnectionClosed"</span>);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"断开连接-&gt;&#123;&#125;"</span>,session);</span><br><span class="line">        WebSocketCountUtil.onlineCountReduce(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否处理分片消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 管理员连接处理的Handler，管理员查看实时用户情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminConnectionHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"管理员连接成功-&gt;&#123;&#125;"</span>,session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message;</span><br><span class="line">        log.warn(<span class="string">"收到消息-&gt;&#123;&#125;"</span>,textMessage);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        MessageEntity messageEntity = JSONObject.parseObject(textMessage.getPayload(), MessageEntity.class);</span><br><span class="line">        WebSocketCountUtil.adminSessionAdd(session,messageEntity.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传输消息出错"</span>+<span class="string">"afterConnectionClosed"</span>);</span><br><span class="line">        System.out.println(session);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"管理员断开连接-&gt;&#123;&#125;"</span>,session);</span><br><span class="line">        WebSocketCountUtil.adminSessionReduce(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebSocket配置文件"><a href="#WebSocket配置文件" class="headerlink" title="WebSocket配置文件"></a>WebSocket配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>:WebSocket配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> UserConnectionHandler(),<span class="string">"/ws/userCount"</span>) <span class="comment">// 普通用户websocket的连接路径</span></span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> HttpSessionHandshakeInterceptor())</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>);</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> AdminConnectionHandler(),<span class="string">"/ws/admin"</span>) <span class="comment">// 管理员websocket的连接路径</span></span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> HttpSessionHandshakeInterceptor())</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下是配置WebSocket的配置属性，例如消息缓冲区大小，空闲超时等。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletServerContainerFactoryBean <span class="title">createWebSocketContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletServerContainerFactoryBean container = <span class="keyword">new</span> ServletServerContainerFactoryBean();</span><br><span class="line">        container.setMaxTextMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        container.setMaxBinaryMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        container.setMaxSessionIdleTimeout(<span class="number">300000L</span>);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上核心代码已贴出，完整代码参考<a href="https://github.com/XiumingLee/MingRepository/tree/master/websocket" target="_blank" rel="noopener">GitHub源码</a>。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>以七牛云为例，手写一个Spring Boot的Starter</title>
    <url>/Spring-Boot/%E4%BB%A5%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AASpring-Boot%E7%9A%84Starter.html</url>
    <content><![CDATA[<h1 id="GitHub源码地址"><a href="#GitHub源码地址" class="headerlink" title="GitHub源码地址"></a><a href="https://github.com/XiumingLee/MingRepository" target="_blank" rel="noopener">GitHub源码地址</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们使用 Spring Boot，基本上都是沉醉在它 Stater 的方便之中。Starter 为我们带来了众多的自动化配置，有了这些自动化配置，我们可以不费吹灰之力就能搭建一个生产级开发环境，其实 Starter 的核心就是条件注解 <code>@Conditional</code> ，当 <code>classpath</code>下存在某一个<code>Class</code>时，某个配置才会生效,下面就以七牛云为例，写一个简单的<code>Spring  Boot  Starter</code>。</p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="http://qiniu.mrain22.cn/201906021031_134.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>1、创建一个普通的Maven项目，pom文件中加入以下依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.mrain22.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--七牛--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、编写一个<code>MqiniuProperties</code>,用来接受 <code>application.properties</code>中注入的值，如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrain22.qiniu;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/6/1 12:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 七牛配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mqiniu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqiniuProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** accessKey*/</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="comment">/** secretKey*/</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="comment">/** 要上传的空间*/</span></span><br><span class="line">    <span class="keyword">private</span>  String bucketName;</span><br><span class="line">    <span class="comment">/** 文件地址前缀，cdn地址*/</span></span><br><span class="line">    <span class="keyword">private</span> String filePathPrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里省略了 get/set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、编写校验类<code>MqiniuCondition</code>，用来校验用户必要的配置信息是否填写。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrain22.qiniu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/6/1 16:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 校验类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqiniuCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        String ak = context.getEnvironment().getProperty(<span class="string">"mqiniu.access-key"</span>);</span><br><span class="line">        String sk = context.getEnvironment().getProperty(<span class="string">"mqiniu.secret-key"</span>);</span><br><span class="line">        String bucketName = context.getEnvironment().getProperty(<span class="string">"mqiniu.bucket-name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 校验用户是否将配置信息填写完整*/</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(ak)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lack of qiniuyun configuration:access-key"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isEmpty(sk)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lack of mqiniuyun configuration:secret-key"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isEmpty(bucketName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lack of qiniuyun configuration:bucket-name"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、编写供调用的接口<code>MqiniuService</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrain22.qiniu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qiniu.common.QiniuException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/6/1 16:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 七牛上传服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MqiniuService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileBytes 文件的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名带后缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上传后文件的url路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileBytes, String fileName)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 上传文件后返回的url路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteByKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、编写默认的实现类<code>MqiniuServiceImpl</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrain22.qiniu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.common.QiniuException;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.http.Response;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.storage.BucketManager;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.storage.UploadManager;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.storage.model.DefaultPutRet;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.util.Auth;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/6/1 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>: 七牛上传删除实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqiniuServiceImpl</span> <span class="keyword">implements</span> <span class="title">MqiniuService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UploadManager uploadManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BucketManager bucketManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqiniuProperties mqiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileBytes, String fileName)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        String fileExtName = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">        String newFileName = UUID.randomUUID() + <span class="string">"."</span> + fileExtName;</span><br><span class="line">        Response response = uploadManager.put(fileBytes, newFileName, getUploadToken());</span><br><span class="line">        <span class="comment">//解析上传成功的结果</span></span><br><span class="line">        DefaultPutRet putRet = <span class="keyword">new</span> Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">        String key = mqiniuProperties.getFilePathPrefix() + putRet.key;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteByKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        key = key.replace(mqiniuProperties.getFilePathPrefix(),<span class="string">""</span>);</span><br><span class="line">        bucketManager.delete(mqiniuProperties.getBucketName(), key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上传凭证，普通上传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUploadToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.auth.uploadToken(mqiniuProperties.getBucketName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、接下来就是我们的重轴戏，自动配置类的定义.<code>MqiniuServiceAutoConfiguration</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrain22.qiniu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Xiuming Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/6/1 16:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Describe</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 装配配置属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qiniu.common.Region;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.storage.BucketManager;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.storage.UploadManager;</span><br><span class="line"><span class="keyword">import</span> com.qiniu.util.Auth;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 自动装配这个properties类，读取yaml自定义内容</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MqiniuProperties.class)</span><br><span class="line"><span class="comment">// service类，@ConditionalOnClass某个 Class 位于类路径上，才会实例化一个Bean。也就是说，当classpath下发现该类的情况下进行实例化。</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(MqiniuService.class)</span><br><span class="line"><span class="comment">// 校验类</span></span><br><span class="line"><span class="meta">@Conditional</span>(MqiniuCondition.class)</span><br><span class="line"><span class="comment">// 当配置文件中 mqiniu 的值为 true 时，实例化此类。可以不填</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"mqiniu"</span>, value = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqiniuServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqiniuProperties mqiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定实例化接口的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ConditionalOnMissingBean</span> 当spring容器中不存在MqiniuService的实例时，默认调用这个。</span></span><br><span class="line"><span class="comment">     * 如果你实现了MqiniuService接口，并添加到了Spring容器，则会使用你的MqiniuService实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MqiniuService <span class="title">qiNiuYunService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MqiniuServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个七牛上传工具实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadManager <span class="title">uploadManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UploadManager(<span class="keyword">new</span> com.qiniu.storage.Configuration(Region.autoRegion()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证信息实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auth <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Auth.create(mqiniuProperties.getAccessKey(), mqiniuProperties.getSecretKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建七牛空间管理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BucketManager <span class="title">bucketManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BucketManager(auth(),<span class="keyword">new</span> com.qiniu.storage.Configuration(Region.autoRegion()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、<strong>让<code>spring boot</code>加载我们的装配类，需要在<code>resource</code>目录下新建<code>META-INF/spring.factories</code>内容如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.mrain22.qiniu.MqiniuServiceAutoConfiguration</span><br></pre></td></tr></table></figure>
<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>完成以上步骤，一个简单<code>Spring  Boot  Starter</code>也就写完了，下一步就是将其发布到Maven仓库，我这里就简单点，只发布到本地。</p>
<p>方式很简单，在<code>IntelliJ IDEA</code> 中，点击右边的 <code>Maven Project</code>，然后选择 <code>Lifecycle</code> 中的 <code>install</code>，双击即可，如下：</p>
<p><img src="http://qiniu.mrain22.cn/201906021050_155.png" alt=""></p>
<p>双击完成后，这个 <code>Starter</code>就安装到我们本地仓库了。</p>
<h2 id="使用-Starter"><a href="#使用-Starter" class="headerlink" title="使用 Starter"></a>使用 Starter</h2><p>在我们需要的项目中引入依赖即可。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.mrain22.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>application.properties</code>中添加以下属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mqiniu.access-key=your qiniu`s ak</span><br><span class="line">mqiniu.secret-key=your qiniu`s sk</span><br><span class="line">mqiniu.bucket-name=空间名称</span><br><span class="line">mqiniu.file-path-prefix=your qiniu cdn url</span><br></pre></td></tr></table></figure>
<p>代码使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MqiniuService mqiniuService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">fileUploadTest</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] fileBytes = file.getBytes();</span><br><span class="line">       String filename = file.getOriginalFilename();</span><br><span class="line">       String url = mqiniuService.uploadFile(fileBytes, filename);</span><br><span class="line">       <span class="keyword">return</span> url;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p># </p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot、SpringSecurity、Vue整合JWT认证</title>
    <url>/Spring-Boot/SpringBoot%E3%80%81SpringSecurity%E3%80%81Vue%E6%95%B4%E5%90%88JWT%E8%AE%A4%E8%AF%81.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在开始这篇文章前，博主默认你们已经对Spring Boot、Spring Security、Vue以及JWT已经了解。这里对以上概念也不再赘述。下面先讲一下思路。</p>
<blockquote>
<p>1、后端需要编写JWT生成处理和JWT解析认证处理。</p>
<p>2、前端填写用户名和密码发送登录请求。</p>
<p>3、经后端Spring Security登录认证成功后，由JWT生成器生成<code>Token</code>返回给前端。</p>
<p>4、前端拿到<code>Token</code>，在之后的请求中需要携带这个<code>Token</code>。</p>
<p>5、后端编写JWT过滤器，对请求中的<code>Token</code>进行解析处理，解析成功通过，失败返回相应提示。</p>
</blockquote>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://qiniu.mrain22.cn/201905211829_763.gif" alt=""></p>
<blockquote>
<p><code>hello</code>按钮不需要登录，<code>测试1</code>和<code>测试2</code>按钮需要登录才能访问。点击登录后会获取<code>Token</code>,下次发送请求携带这个<code>Token</code>.</p>
<p><a href="https://github.com/XiumingLee/SpringBootVueJWT" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><ul>
<li><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4></li>
</ul>
<h4 id="1、在用户成功登录后下发Token"><a href="#1、在用户成功登录后下发Token" class="headerlink" title="1、在用户成功登录后下发Token"></a>1、在用户成功登录后下发Token</h4><p><code>Spring Security</code>在做登录操作的时候允许我们添加我们的自己的<code>登录成功处理器</code>和<code>登录失败处理器</code>。这里我编写了自己的<code>成功处理器</code>和<code>失败处理器</code>。在<code>成功处理器</code>中添加了生成<code>JWT</code>的操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的登录成功处理器</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myLoginSuccessHandler"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoginSuccessHandler</span> <span class="keyword">extends</span> <span class="title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"登录成功！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        登录成功后设置JWT</span></span><br><span class="line">        String Token = Jwts.builder()</span><br><span class="line">                <span class="comment">//设置token的信息</span></span><br><span class="line"><span class="comment">//                .setClaims(claimsMap)</span></span><br><span class="line">                <span class="comment">//将认证后的authentication写入token，验证时，直接验证它</span></span><br><span class="line">                .claim(<span class="string">"authentication"</span>,authentication)</span><br><span class="line">                <span class="comment">//设置主题</span></span><br><span class="line">                .setSubject(<span class="string">"主题"</span>)</span><br><span class="line">                <span class="comment">//过期时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">1000</span>))</span><br><span class="line">                <span class="comment">//加密方式</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, <span class="string">"MyJWTtest"</span>)</span><br><span class="line">                .compact();</span><br><span class="line">        httpServletResponse.addHeader(<span class="string">"Authorization"</span>, <span class="string">"Mrain"</span> + Token);</span><br><span class="line">        <span class="comment">//要做的工作就是将Authentication以json的形式返回给前端。 需要工具类ObjectMapper，Spring已自动注入。</span></span><br><span class="line">        <span class="comment">//设置返回类型</span></span><br><span class="line">        httpServletResponse.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        Map&lt;String, Object&gt; tokenInfo = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        tokenInfo.put(<span class="string">"Authorization"</span>,<span class="string">"Mrain"</span> + Token);</span><br><span class="line">        <span class="comment">//将token信息写入</span></span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(tokenInfo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义登录失败处理器</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myLoginFailureHandler"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoginFailureHandler</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ObjectMapper这个类是java中jackson提供的，主要是用来把对象转换成为一个json字符串返回到前端,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//json形式返回</span></span><br><span class="line">        <span class="comment">//服务器内部异常</span></span><br><span class="line">        response.setStatus(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//设置返回类型</span></span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">//将错误信息写入</span></span><br><span class="line">       response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、JWT拦截器"><a href="#2、JWT拦截器" class="headerlink" title="2、JWT拦截器"></a>2、JWT拦截器</h4><p>定义我们自己的<code>JWT拦截器</code>，在请求到达目标之前对<code>Token</code>进行校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JWT拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取JWT</span></span><br><span class="line">        String authHeader = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        logger.info(<span class="string">"---------&gt;"</span>+authHeader);</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析token.</span></span><br><span class="line">            Claims claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(<span class="string">"MyJWTtest"</span>)</span><br><span class="line">                    .parseClaimsJws(authHeader.replace(<span class="string">"Mrain"</span>, <span class="string">""</span>))</span><br><span class="line">                    .getBody();</span><br><span class="line">            <span class="comment">//获取suject</span></span><br><span class="line"><span class="comment">//            String subject = claims.getSubject();</span></span><br><span class="line"><span class="comment">//            User user = (User) claims.get("user");</span></span><br><span class="line">            <span class="comment">//获取过期时间</span></span><br><span class="line">            Date claimsExpiration = claims.getExpiration();</span><br><span class="line">            logger.info(<span class="string">"过期时间"</span>+claimsExpiration);</span><br><span class="line">            <span class="comment">//判断是否过期</span></span><br><span class="line">            Date now = <span class="keyword">new</span> Date();</span><br><span class="line">            <span class="keyword">if</span> (now.getTime() &gt; claimsExpiration.getTime()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"凭证已过期，请重新登录！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取保存在token中的登录认证成功的authentication，</span></span><br><span class="line">            <span class="comment">// 利用UsernamePasswordAuthenticationToken生成新的authentication</span></span><br><span class="line">            <span class="comment">// 放入到SecurityContextHolder，表示认证通过</span></span><br><span class="line">            Object tokenInfo = claims.get(<span class="string">"authentication"</span>);</span><br><span class="line">            <span class="comment">//通过com.alibaba.fastjson将其在转换。</span></span><br><span class="line">            Authentication toknAuthentication = JSONObject.parseObject(JSONObject.toJSONString(tokenInfo), Authentication.class);</span><br><span class="line">            UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(toknAuthentication.getPrincipal(),<span class="keyword">null</span>,toknAuthentication.getAuthorities());</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、配置Spring-Security的配置"><a href="#3、配置Spring-Security的配置" class="headerlink" title="3、配置Spring Security的配置"></a>3、配置Spring Security的配置</h4><p>将<code>两个处理器</code>和我们的<code>Jwt拦截器</code>添加到<code>Spring Security</code>的配置中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyLoginSuccessHandler myLoginSuccessHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyLoginFailureHandler myLoginFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/** JWT拦截器*/</span></span><br><span class="line">        JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter = <span class="keyword">new</span> JwtAuthenticationTokenFilter();</span><br><span class="line">        <span class="comment">/** 将JWT拦截器添加到UsernamePasswordAuthenticationFilter之前*/</span></span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        http.formLogin()</span><br><span class="line">                .loginPage(<span class="string">"/loginInfo"</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">"/login"</span>)</span><br><span class="line">                .successHandler(myLoginSuccessHandler)</span><br><span class="line">                .failureHandler(myLoginFailureHandler);</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/hello"</span>,<span class="string">"/login"</span>,<span class="string">"/loginInfo"</span>,<span class="string">"/logoutSuccess"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">        <span class="comment">//访问 /logout 表示用户注销，并清空session</span></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">"/logoutSuccess"</span>);</span><br><span class="line">        <span class="comment">// 关闭csrf</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        http.cors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码加盐加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Spring自带的每次会随机生成盐值，即使密码相同，加密后也不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h3><p>前端实现很简单，就是登录成功后，将返回的<code>token</code>保存起来，以后每次访问请求头携带这个<code>token</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$http</span><br><span class="line">        .post(<span class="string">"/login"</span>, &#123;</span><br><span class="line">          username: <span class="number">1</span>,</span><br><span class="line">          password: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 登录成功</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"登录成功！"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(res.data);</span><br><span class="line">           <span class="comment">/** 将Token保存到localStorage*/</span></span><br><span class="line">          <span class="keyword">const</span> authorization = res.data.Authorization;</span><br><span class="line">          localStorage.token = authorization;</span><br><span class="line">          <span class="keyword">this</span>.msg = authorization;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"登录失败！"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(error);</span><br><span class="line">          <span class="keyword">this</span>.msg = error;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用axios发送请求的设置</span></span><br><span class="line"><span class="comment">// 在发送请求之前做某件事</span></span><br><span class="line">Axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置以 form 表单的形式提交参数，如果以JSON的形式提交表单，可忽略</span></span><br><span class="line">    <span class="keyword">if</span>(config.method  === <span class="string">'post'</span>)&#123;</span><br><span class="line">        <span class="comment">// JSON 转换为 FormData</span></span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">        <span class="built_in">Object</span>.keys(config.data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> formData.append(key, config.data[key]))</span><br><span class="line">        config.data = formData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本案例中将token保存到了localStorage，将其添加到请求头</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.token) &#123;   </span><br><span class="line">        config.headers.Authorization = localStorage.token</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,error =&gt;&#123;</span><br><span class="line">    alert(<span class="string">"错误的传参"</span>, <span class="string">'fail'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/XiumingLee/SpringBootVueJWT" target="_blank" rel="noopener">源码地址</a></h3>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6、ES7、ES8、ES9、ES10新特性一览</title>
    <url>/%E8%BD%AC%E8%BD%BD/ES6%E3%80%81ES7%E3%80%81ES8%E3%80%81ES9%E3%80%81ES10%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88.html</url>
    <content><![CDATA[<blockquote>
<p>ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为<a href="https://link.juejin.im?target=https%3A%2F%2Fecma-international.org%2Fpublications%2Fstandards%2FEcma-417.htm" target="_blank" rel="noopener">ECMA-417</a>。关于ECMA的最新资讯可以浏览 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.ecma-international.org%2Fnews%2Findex.html" target="_blank" rel="noopener">ECMA news</a>查看。</p>
</blockquote>
<p>ECMA规范最终由<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftc39" target="_blank" rel="noopener">TC39</a>敲定。TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript提案沿着一条严格的发展道路前进。 从提案到入选ECMA规范主要有以下几个阶段：</p>
<ul>
<li>Stage 0: strawman——最初想法的提交。</li>
<li>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。</li>
<li>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。</li>
<li>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈</li>
<li>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间。</li>
</ul>
<h2 id="ES6新特性（2015）"><a href="#ES6新特性（2015）" class="headerlink" title="ES6新特性（2015）"></a>ES6新特性（2015）</h2><p>ES6的特性比较多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度很大，所以ES6中的特性比较多。 在这里列举几个常用的：</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let与Const</li>
</ul>
<h3 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1.类（class）"></a>1.类（class）</h3><p>对熟悉Java，object-c，c#等纯面向对象语言的开发者来说，都会对class有一种特殊的情怀。ES6 引入了class（类），让JavaScript的面向对象编程变得更加简单和易于理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span></span><br><span class="line">   <span class="keyword">constructor</span>(name,color) &#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// toString 是原型对象上的属性</span></span><br><span class="line">   toString() &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'name:'</span> + <span class="keyword">this</span>.name + <span class="string">',color:'</span> + <span class="keyword">this</span>.color);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>,<span class="string">'white'</span>);<span class="comment">//实例化Animal</span></span><br><span class="line">animal.toString();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">'toString'</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.hasOwnProperty(<span class="string">'toString'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(action) &#123;</span><br><span class="line">   <span class="comment">// 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.</span></span><br><span class="line">   <span class="comment">// 如果没有置顶consructor,默认带super函数的constructor将会被添加、</span></span><br><span class="line">   <span class="keyword">super</span>(<span class="string">'cat'</span>,<span class="string">'white'</span>);</span><br><span class="line">   <span class="keyword">this</span>.action = action;</span><br><span class="line"> &#125;</span><br><span class="line"> toString() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">super</span>.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">'catch'</span>)</span><br><span class="line">cat.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="2-模块化-Module"><a href="#2-模块化-Module" class="headerlink" title="2.模块化(Module)"></a>2.模块化(Module)</h3><p>ES5不支持原生的模块化，在ES6中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<h4 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h4><p>ES6允许在一个模块中使用export来导出多个变量或函数。</p>
<p><strong>导出变量</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">'Rainbow'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>心得：ES6不仅支持变量的导出，也支持常量的导出。 <code>export const sqrt = Math.sqrt;//导出常量</code></p>
</blockquote>
<p>ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Rainbow'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="string">'24'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, age&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>导出函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myModule.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params">someArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someArg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h4><p>定义好模块的输出以后就可以在另外一个模块通过import引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myModule&#125; <span class="keyword">from</span> <span class="string">'myModule'</span>;<span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name,age&#125; <span class="keyword">from</span> <span class="string">'test'</span>;<span class="comment">// test.js</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>心得:一条import 语句可以同时导入默认函数和其它变量。<code>import defaultMethod, { otherMethod } from &#39;xxx.js&#39;;</code></p>
</blockquote>
<h3 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3.箭头（Arrow）函数"></a>3.箭头（Arrow）函数</h3><p>这是ES6中最令人激动的特性之一。<code>=&gt;</code>不只是关键字function的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个<code>this</code>,能帮你很好的解决this的指向问题。有经验的JavaScript开发者都熟悉诸如<code>var self = this;</code>或<code>var that = this</code>这种引用外围this的模式。但借助<code>=&gt;</code>，就不需要这种模式了。</p>
<h4 id="箭头函数的结构"><a href="#箭头函数的结构" class="headerlink" title="箭头函数的结构"></a>箭头函数的结构</h4><p>箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数的例子</span></span><br><span class="line">()=&gt;<span class="number">1</span></span><br><span class="line">v=&gt;v+<span class="number">1</span></span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    alert(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line">e=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>/e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>心得：不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
</blockquote>
<h4 id="卸载监听器时的陷阱"><a href="#卸载监听器时的陷阱" class="headerlink" title="卸载监听器时的陷阱"></a>卸载监听器时的陷阱</h4><blockquote>
<p><strong>错误的做法</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>.onAppPaused.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>.onAppPaused.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused(event)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>正确的做法</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>._onAppPaused = <span class="keyword">this</span>.onAppPaused.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused(event)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除上述的做法外，我们还可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">'change'</span>, <span class="keyword">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是：不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
</blockquote>
<h3 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4.函数参数默认值"></a>4.<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2Fdefault_parameters" target="_blank" rel="noopener">函数参数默认值</a></h3><p>ES6支持在定义函数的时候为其设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">'red'</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不使用默认值：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height, color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写一般没问题，但当<code>参数的布尔值为false</code>时，就会有问题了。比如，我们这样调用foo函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(<span class="number">0</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>因为<code>0的布尔值为false</code>，这样height的取值将是50。同理color的取值为‘red’。</p>
<p>所以说，<code>函数参数默认值</code>不仅能是代码变得更加简洁而且能规避一些问题。</p>
<h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h3><p>ES6支持<code>模板字符串</code>，使得字符串的拼接更加的简洁、直观。</p>
<blockquote>
<p>不使用模板字符串：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Your name is '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用模板字符串：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span></span><br></pre></td></tr></table></figure>
<p>在ES6中通过<code>${}</code>就可以完成字符串的拼接，只需要将变量放在大括号之中。</p>
<h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6.解构赋值"></a>6.<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring_assignment" target="_blank" rel="noopener">解构赋值</a></h3><p>解构赋值语法是JavaScript的一种表达式，可以方便的从数组或者对象中快速提取值赋给定义的变量。</p>
<h4 id="获取数组中的值"><a href="#获取数组中的值" class="headerlink" title="获取数组中的值"></a>获取数组中的值</h4><p>从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [one, two, three] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// "one"</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">// "two"</span></span><br><span class="line"><span class="built_in">console</span>.log(three); <span class="comment">// "three"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你要忽略某些值，你可以按照下面的写法获取你想要的值</span></span><br><span class="line"><span class="keyword">var</span> [first, , , last] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// "one"</span></span><br><span class="line"><span class="built_in">console</span>.log(last); <span class="comment">// "four"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//你也可以这样写</span></span><br><span class="line"><span class="keyword">var</span> a, b; <span class="comment">//先声明变量</span></span><br><span class="line"></span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如果没有从数组中的获取到值，你可以为变量设置一个默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">[a=<span class="number">5</span>, b=<span class="number">7</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>通过解构赋值可以方便的交换两个变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="获取对象中的值"><a href="#获取对象中的值" class="headerlink" title="获取对象中的值"></a>获取对象中的值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  name:<span class="string">'Ming'</span>,</span><br><span class="line">  age:<span class="string">'18'</span>,</span><br><span class="line">  city:<span class="string">'Shanghai'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,city&#125; = student;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "Ming"</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// "18"</span></span><br><span class="line"><span class="built_in">console</span>.log(city); <span class="comment">// "Shanghai"</span></span><br></pre></td></tr></table></figure>
<h3 id="7-延展操作符-Spread-operator"><a href="#7-延展操作符-Spread-operator" class="headerlink" title="7.延展操作符(Spread operator)"></a>7.延展操作符(Spread operator)</h3><p><code>延展操作符...</code>可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造对象时, 将对象表达式按key-value的方式展开。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote>
<p>函数调用：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组构造或字符串：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...iterableObj, <span class="string">'4'</span>, ...<span class="string">'hello'</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造对象时,进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objClone = &#123; ...obj &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>在函数调用时使用延展操作符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, numbers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...numbers));<span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造数组</p>
</blockquote>
<p>没有展开语法的时候，只能组合使用 push，splice，concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法, 构造新数组会变得更简单、更优雅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stuendts = [<span class="string">'Jine'</span>,<span class="string">'Tom'</span>]; </span><br><span class="line"><span class="keyword">const</span> persons = [<span class="string">'Tony'</span>,... stuendts,<span class="string">'Aaron'</span>,<span class="string">'Anna'</span>];</span><br><span class="line">conslog.log(persions)<span class="comment">// ["Tony", "Jine", "Tom", "Aaron", "Anna"]</span></span><br></pre></td></tr></table></figure>
<p>和参数列表的展开类似,  <code>...</code> 在构造字数组时, 可以在任意位置多次使用。</p>
<blockquote>
<p>数组拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// 等同于 arr.slice()</span></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。</p>
<blockquote>
<p>连接多个数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];<span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.concat(arr2);</span><br></pre></td></tr></table></figure>
<h4 id="在ECMAScript-2018中延展操作符增加了对对象的支持"><a href="#在ECMAScript-2018中延展操作符增加了对对象的支持" class="headerlink" title="在ECMAScript 2018中延展操作符增加了对对象的支持"></a>在ECMAScript 2018中延展操作符增加了对对象的支持</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 在React中的应用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props 。但是当传递大量的props时，会非常繁琐，这时我们可以使用 `</span>...(延展操作符,用于取出参数对象的所有可遍历属性)<span class="string">` 来进行传递。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 一般情况下我们应该这样写</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">&lt;CustomComponent name =<span class="string">'Jine'</span> age =&#123;<span class="number">21</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 … ，等同于上面的写法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">	name: <span class="string">'Jine'</span>,</span><br><span class="line">	age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;CustomComponent &#123;...params&#125; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配合解构赋值避免传入一些不需要的参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">	name: <span class="string">'123'</span>,</span><br><span class="line">	title: <span class="string">'456'</span>,</span><br><span class="line">	type: <span class="string">'aaa'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; type, ...other &#125; = params;</span><br><span class="line"></span><br><span class="line">&lt;CustomComponent type=<span class="string">'normal'</span> number=&#123;<span class="number">2</span>&#125; &#123;...other&#125; /&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">&lt;CustomComponent type=<span class="string">'normal'</span> number=&#123;<span class="number">2</span>&#125; name=<span class="string">'123'</span> title=<span class="string">'456'</span> /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h3><p>在ES6中允许我们在设置一个对象的属性的时候不指定属性名。</p>
<blockquote>
<p>不使用ES6</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">'Ming'</span>,age=<span class="string">'18'</span>,city=<span class="string">'Shanghai'</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name:name,</span><br><span class="line">    age:age,</span><br><span class="line">    city:city</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student);<span class="comment">//&#123;name: "Ming", age: "18", city: "Shanghai"&#125;</span></span><br></pre></td></tr></table></figure>
<p>对象中必须包含属性和值，显得非常冗余。</p>
<blockquote>
<p>使用ES6</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">'Ming'</span>,age=<span class="string">'18'</span>,city=<span class="string">'Shanghai'</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    city</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student);<span class="comment">//&#123;name: "Ming", age: "18", city: "Shanghai"&#125;</span></span><br></pre></td></tr></table></figure>
<p>对象中直接写变量，非常简洁。</p>
<h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9.Promise"></a>9.<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FUsing_promises" target="_blank" rel="noopener">Promise</a></h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<blockquote>
<p>不使用ES6</p>
</blockquote>
<p>嵌套两个setTimeout回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>); <span class="comment">// 1秒后输出"Hello"</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hi'</span>); <span class="comment">// 2秒后输出"Hi"</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ES6</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> waitSecond = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitSecond</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Hello"</span>); <span class="comment">// 1秒后输出"Hello"</span></span><br><span class="line">      <span class="keyword">return</span> waitSecond;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>); <span class="comment">// 2秒后输出"Hi"</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的的代码使用两个then来进行异步编程串行化，避免了回调地狱：</p>
<h3 id="10-支持let与const"><a href="#10-支持let与const" class="headerlink" title="10.支持let与const"></a>10.支持let与const</h3><p>在之前JS是没有块级作用域的，const与let填补了这方便的空白，const与let都是块级作用域。</p>
<blockquote>
<p>使用var定义的变量为函数级作用域：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用let与const定义的变量为块级作用域：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//-1 or Error“ReferenceError: a is not defined”</span></span><br></pre></td></tr></table></figure>
<h2 id="ES7新特性（2016）"><a href="#ES7新特性（2016）" class="headerlink" title="ES7新特性（2016）"></a>ES7新特性（2016）</h2><p>ES2016添加了两个小的特性来说明标准化过程：</p>
<ul>
<li>数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</li>
<li>a ** b指数运算符，它与 Math.pow(a, b)相同。</li>
</ul>
<h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h3><p><code>includes()</code> 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回<code>false</code>。</p>
<p><code>includes</code> 函数与 <code>indexOf</code> 函数很相似，下面两个表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.includes(x)</span><br><span class="line">arr.indexOf(x) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来判断数字中是否包含某个元素：</p>
<blockquote>
<p>在ES7之前的做法</p>
</blockquote>
<p>使用<code>indexOf()</code>验证数组中是否存在某个元素，这时需要根据返回值是否为-1来判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'react'</span>, <span class="string">'angular'</span>, <span class="string">'vue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">'react'</span>) !== <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'react存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ES7的includes()</p>
</blockquote>
<p>使用includes()验证数组中是否存在某个元素，这样更加直观简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'react'</span>, <span class="string">'angular'</span>, <span class="string">'vue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="string">'react'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'react存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2.指数操作符"></a>2.指数操作符</h3><p>在ES7中引入了指数运算符<code>**</code>，<code>**</code>具有与<code>Math.pow(..)</code>等效的计算结果。</p>
<blockquote>
<p>不使用指数操作符</p>
</blockquote>
<p>使用自定义的递归函数calculateExponent或者Math.pow()进行指数运算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateExponent</span>(<span class="params">base, exponent</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent === <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> base * calculateExponent(base, exponent - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateExponent(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用指数操作符</p>
</blockquote>
<p>使用指数运算符**，就像+、-等操作符一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>);<span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure>
<h2 id="ES8新特性（2017）"><a href="#ES8新特性（2017）" class="headerlink" title="ES8新特性（2017）"></a>ES8新特性（2017）</h2><ul>
<li>async/await</li>
<li><code>Object.values()</code></li>
<li><code>Object.entries()</code></li>
<li>String padding: <code>padStart()</code>和<code>padEnd()</code>，填充字符串达到当前长度</li>
<li>函数参数列表结尾允许逗号</li>
<li><code>Object.getOwnPropertyDescriptors()</code></li>
<li><code>ShareArrayBuffer</code>和<code>Atomics</code>对象，用于从共享内存位置读取和写入</li>
</ul>
<h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1.async/await"></a>1.async/await</h3><p>ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2.Object.values()"></a>2.Object.values()</h3><p><code>Object.values()</code>是一个与<code>Object.keys()</code>类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。</p>
<p>假设我们要遍历如下对象<code>obj</code>的所有值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不使用Object.values() :ES7</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vals=<span class="built_in">Object</span>.keys(obj).map(<span class="function"><span class="params">key</span>=&gt;</span>obj[key]);</span><br><span class="line"><span class="built_in">console</span>.log(vals);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Object.values() :ES8</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const values=Object.values(obj1);</span><br><span class="line">console.log(values);//[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出<code>Object.values()</code>为我们省去了遍历key，并根据这些key获取value的步骤。</p>
<h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.Object.entries()</h3><p><code>Object.entries()</code>函数返回一个给定对象自身可枚举属性的键值对的数组。</p>
<p>接下来我们来遍历上文中的<code>obj</code>对象的所有属性的key和value：</p>
<blockquote>
<p>不使用Object.entries() :ES7</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'key:'</span>+key+<span class="string">' value:'</span>+obj[key]);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Object.entries() :ES8</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1))&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br></pre></td></tr></table></figure>
<h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4.String padding"></a>4.String padding</h3><p>在ES8中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<blockquote>
<p>String.padStart(targetLength,[padString])</p>
</blockquote>
<ul>
<li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0.0'</span>.padStart(<span class="number">4</span>,<span class="string">'10'</span>)) <span class="comment">//10.0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0.0'</span>.padStart(<span class="number">20</span>))<span class="comment">// 0.00</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>String.padEnd(targetLength,padString])</p>
</blockquote>
<ul>
<li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0.0'</span>.padEnd(<span class="number">4</span>,<span class="string">'0'</span>)) <span class="comment">//0.00    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0.0'</span>.padEnd(<span class="number">10</span>,<span class="string">'0'</span>))<span class="comment">//0.00000000</span></span><br></pre></td></tr></table></figure>
<h3 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5.函数参数列表结尾允许逗号"></a>5.函数参数列表结尾允许逗号</h3><p>主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。</p>
<h3 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6.Object.getOwnPropertyDescriptors()"></a>6.Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptors()</code>函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
<blockquote>
<p>函数原型：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br></pre></td></tr></table></figure>
<p>返回<code>obj</code>对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">'Jine'</span>,</span><br><span class="line">	get age() &#123; <span class="keyword">return</span> <span class="string">'18'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj2)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   age: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function age()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//		value:"Jine",</span></span><br><span class="line"><span class="comment">//		writable:true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7.SharedArrayBuffer对象"></a>7.SharedArrayBuffer对象</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。  </span></span><br><span class="line"><span class="comment"> * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> SharedArrayBuffer(length)</span><br></pre></td></tr></table></figure>
<h3 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8.Atomics对象"></a>8.Atomics对象</h3><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。</p>
<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>
<ul>
<li>Atomics.add()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.and()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.compareExchange()</li>
</ul>
<blockquote>
<p>如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</p>
</blockquote>
<ul>
<li>Atomics.exchange()</li>
</ul>
<blockquote>
<p>将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p>
</blockquote>
<ul>
<li>Atomics.load()</li>
</ul>
<blockquote>
<p>返回数组中指定元素的值。</p>
</blockquote>
<ul>
<li>Atomics.or()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.store()</li>
</ul>
<blockquote>
<p>将数组中指定的元素设置为给定的值，并返回该值。</p>
</blockquote>
<ul>
<li>Atomics.sub()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.xor()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p>
</blockquote>
<p>wait() 和 wake() 方法采用的是 Linux 上的 futexes 模型（fast user-space mutex，快速用户空间互斥量），可以让进程一直等待直到某个特定的条件为真，主要用于实现阻塞。</p>
<ul>
<li>Atomics.wait()</li>
</ul>
<blockquote>
<p>检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p>
</blockquote>
<ul>
<li>Atomics.wake()</li>
</ul>
<blockquote>
<p>唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p>
</blockquote>
<ul>
<li>Atomics.isLockFree(size)</li>
</ul>
<blockquote>
<p>可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。–&gt;</p>
</blockquote>
<h2 id="ES9新特性（2018）"><a href="#ES9新特性（2018）" class="headerlink" title="ES9新特性（2018）"></a>ES9新特性（2018）</h2><ul>
<li>异步迭代</li>
<li>Promise.finally()</li>
<li>Rest/Spread 属性</li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fesnext.justjavac.com%2Fproposal%2Fregexp-named-groups.html" target="_blank" rel="noopener">正则表达式命名捕获组</a>（Regular Expression Named Capture Groups）</li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000006824133" target="_blank" rel="noopener">正则表达式反向断言</a>（lookbehind）</li>
<li>正则表达式dotAll模式</li>
<li><a href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1" target="_blank" rel="noopener">正则表达式 Unicode 转义</a></li>
<li><a href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1" target="_blank" rel="noopener">非转义序列的模板字符串</a></li>
</ul>
<h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1.异步迭代"></a>1.异步迭代</h3><p>在<code>async/await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不会正常运行，下面这段同样也不会：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。</p>
<p>ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2.Promise.finally()"></a>2.Promise.finally()</h3><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p><code>.finally()</code>允许你指定最终的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// finish here!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3.Rest/Spread 属性"></a>3.Rest/Spread 属性</h3><p>ES2015引入了<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FRest_parameters" target="_blank" rel="noopener">Rest参数</a>和<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FSpread_syntax" target="_blank" rel="noopener">扩展运算符</a>。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 = 1</span></span><br><span class="line">  <span class="comment">// p2 = 2</span></span><br><span class="line">  <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如<code>Math.max()</code>返回给定数字中的最大值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">99</span>, <span class="number">100</span>, <span class="number">-1</span>, <span class="number">48</span>, <span class="number">16</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...values) ); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...x &#125; = myObject;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<p>或者你可以使用它给函数传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">&#123; a, ...x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a = 1</span></span><br><span class="line">  <span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。</p>
<p>扩展运算符可以在其他对象内使用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">z</span>: <span class="number">26</span> &#125;;</span><br><span class="line"><span class="comment">// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以使用扩展运算符拷贝一个对象，像是这样<code>obj2 = {...obj1}</code>，但是 <strong>这只是一个对象的浅拷贝</strong>。另外，如果一个对象A的属性是对象B，那么在克隆后的对象cloneB中，该属性指向对象B。</p>
<h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4.正则表达式命名捕获组"></a>4.正则表达式命名捕获组</h3><p>JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以<code>YYYY-MM-DD</code>的格式解析日期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">'2018-04-30'</span>),</span><br><span class="line">  year   = match[<span class="number">1</span>], <span class="comment">// 2018</span></span><br><span class="line">  month  = match[<span class="number">2</span>], <span class="comment">// 04</span></span><br><span class="line">  day    = match[<span class="number">3</span>]; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。</p>
<p>ES2018允许命名捕获组使用符号<code>?&lt;name&gt;</code>，在打开捕获括号<code>(</code>后立即命名，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">'2018-04-30'</span>),</span><br><span class="line">  year   = match.groups.year,  <span class="comment">// 2018</span></span><br><span class="line">  month  = match.groups.month, <span class="comment">// 04</span></span><br><span class="line">  day    = match.groups.day;   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>任何匹配失败的命名组都将返回<code>undefined</code>。</p>
<p>命名捕获也可以使用在<code>replace()</code>方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  d      = <span class="string">'2018-04-30'</span>,</span><br><span class="line">  usDate = d.replace(reDate, <span class="string">'$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5.正则表达式反向断言"></a>5.正则表达式反向断言</h3><p>目前JavaScript在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookahead = <span class="regexp">/\D(?=\d+)/</span>,</span><br><span class="line">  match       = reLookahead.exec(<span class="string">'$123.89'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// $</span></span><br></pre></td></tr></table></figure>
<p>ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehind = <span class="regexp">/(?&lt;=\D)\d+/</span>,</span><br><span class="line">  match        = reLookbehind.exec(<span class="string">'$123.89'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// 123.89</span></span><br></pre></td></tr></table></figure>
<p>以上是 <strong>肯定反向断言</strong>，非数字<code>\D</code>必须存在。同样的，还存在 <strong>否定反向断言</strong>，表示一个值必须不存在，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehindNeg = <span class="regexp">/(?&lt;!\D)\d+/</span>,</span><br><span class="line">  match           = reLookbehind.exec(<span class="string">'$123.89'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6.正则表达式dotAll模式"></a>6.正则表达式dotAll模式</h3><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许行终止符的出现，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">'hello\nworld'</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">'hello\nworld'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-正则表达式-Unicode-转义"><a href="#7-正则表达式-Unicode-转义" class="headerlink" title="7.正则表达式 Unicode 转义"></a>7.正则表达式 Unicode 转义</h3><p>到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">reGreekSymbol.test(<span class="string">'π'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。</p>
<h3 id="8-非转义序列的模板字符串"><a href="#8-非转义序列的模板字符串" class="headerlink" title="8.非转义序列的模板字符串"></a>8.非转义序列的模板字符串</h3><p>之前，<code>\u</code>开始一个 unicode 转义，<code>\x</code>开始一个十六进制转义，<code>\</code>后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 <code>C:\uuu\xxx\111</code>。更多细节参考<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2Ftemplate_strings" target="_blank" rel="noopener">模板字符串</a>。</p>
<h2 id="ES10新特性（2019）"><a href="#ES10新特性（2019）" class="headerlink" title="ES10新特性（2019）"></a>ES10新特性（2019）</h2><ul>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</li>
<li>更加友好的 JSON.stringify</li>
<li>新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</li>
<li>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法</li>
<li><code>Object.fromEntries()</code></li>
<li><code>Symbol.prototype.description</code></li>
<li><code>String.prototype.matchAll</code></li>
<li><code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</li>
<li>简化<code>try {} catch {}</code>,修改 <code>catch</code> 绑定</li>
<li>新的基本数据类型<code>BigInt</code></li>
<li>globalThis</li>
<li>import()</li>
<li>Legacy RegEx</li>
<li>私有的实例方法和访问器</li>
</ul>
<h3 id="1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配"><a href="#1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配" class="headerlink" title="1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配"></a>1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</h3><p>以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致SyntaxError异常。</p>
<h3 id="2-更加友好的-JSON-stringify"><a href="#2-更加友好的-JSON-stringify" class="headerlink" title="2.更加友好的 JSON.stringify"></a>2.更加友好的 JSON.stringify</h3><p>如果输入 Unicode 格式但是超出范围的字符，在原先JSON.stringify返回格式错误的Unicode字符串。现在实现了一个改变JSON.stringify的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-well-formed-stringify" target="_blank" rel="noopener">第3阶段提案</a>，因此它为其输出转义序列，使其成为有效Unicode（并以UTF-8表示）</p>
<h3 id="3-新增了Array的flat-方法和flatMap-方法"><a href="#3-新增了Array的flat-方法和flatMap-方法" class="headerlink" title="3.新增了Array的flat()方法和flatMap()方法"></a>3.新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</h3><p><code>flat()</code>和<code>flatMap()</code>本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<h4 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h4><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<ul>
<li><code>flat()</code>方法最基本的作用就是数组降维</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr3.flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span></span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其次，还可以利用<code>flat()</code>方法的特性来去除数组的空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat();</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 这里我们拿map方法与flatMap方法做一个比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-新增了String的trimStart-方法和trimEnd-方法"><a href="#4-新增了String的trimStart-方法和trimEnd-方法" class="headerlink" title="4.新增了String的trimStart()方法和trimEnd()方法"></a>4.新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法</h3><p>新增的这两个方法很好理解，分别去除字符串首尾空白字符，这里就不用例子说声明了。</p>
<h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5.Object.fromEntries()"></a>5.<code>Object.fromEntries()</code></h3><p><code>Object.entries()</code>方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<p><strong>而Object.fromEntries() 则是 Object.entries() 的反转。</strong></p>
<p><code>Object.fromEntries()</code> 函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。</p>
<ul>
<li>通过 Object.fromEntries， 可以将 Map 转化为 Object:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">'foo'</span>, <span class="string">'bar'</span>], [<span class="string">'baz'</span>, <span class="number">42</span>] ]);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 Object.fromEntries， 可以将 Array 转化为 Object:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ [<span class="string">'0'</span>, <span class="string">'a'</span>], [<span class="string">'1'</span>, <span class="string">'b'</span>], [<span class="string">'2'</span>, <span class="string">'c'</span>] ];</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; 0: "a", 1: "b", 2: "c" &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-Symbol-prototype-description"><a href="#6-Symbol-prototype-description" class="headerlink" title="6.Symbol.prototype.description"></a>6.<code>Symbol.prototype.description</code></h3><p>通过工厂函数Symbol（）创建符号时，您可以选择通过参数提供字符串作为描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'The description'</span>);</span><br></pre></td></tr></table></figure>
<p>以前，访问描述的唯一方法是将符号转换为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(<span class="built_in">String</span>(sym), <span class="string">'Symbol(The description)'</span>);</span><br></pre></td></tr></table></figure>
<p>现在引入了getter Symbol.prototype.description以直接访问描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(sym.description, <span class="string">'The description'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7.String.prototype.matchAll"></a>7.<code>String.prototype.matchAll</code></h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。 在 matchAll 出现之前，通过在循环中调用regexp.exec来获取所有匹配项信息（regexp需使用/g标志：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'table football, foosball'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regexp.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: "Found foo. Next starts at 9."</span></span><br><span class="line">  <span class="comment">// expected output: "Found foo. Next starts at 19."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用／g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for…of, array spread, or Array.from() 可以更方便实现功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>); </span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'table football, foosball'</span>;</span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ "foo" ]</span></span><br><span class="line"><span class="comment">// Array [ "foo" ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// matches iterator is exhausted after the for..of iteration</span></span><br><span class="line"><span class="comment">// Call matchAll again to create a new iterator</span></span><br><span class="line">matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(matches, m =&gt; m[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Array [ "foo", "foo" ]</span></span><br></pre></td></tr></table></figure>
<h4 id="matchAll可以更好的用于分组"><a href="#matchAll可以更好的用于分组" class="headerlink" title="matchAll可以更好的用于分组"></a>matchAll可以更好的用于分组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'test1test2'</span>;</span><br><span class="line"></span><br><span class="line">str.match(regexp); </span><br><span class="line"><span class="comment">// Array ['test1', 'test2']</span></span><br><span class="line"><span class="keyword">let</span> array = [...str.matchAll(regexp)];</span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4]</span></span><br><span class="line">array[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="8-Function-prototype-toString-现在返回精确字符，包括空格和注释"><a href="#8-Function-prototype-toString-现在返回精确字符，包括空格和注释" class="headerlink" title="8.Function.prototype.toString()现在返回精确字符，包括空格和注释"></a>8.<code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">comment</span> */ <span class="title">foo</span> /* <span class="title">another</span> <span class="title">comment</span> */(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前不会打印注释部分</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">// function foo()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2019 会把注释一同打印</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">// function /* comment */ foo /* another comment */ ()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> bar <span class="comment">/* comment */</span> = <span class="comment">/* another comment */</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString()); <span class="comment">// () =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-修改-catch-绑定"><a href="#9-修改-catch-绑定" class="headerlink" title="9.修改 catch 绑定"></a>9.修改 <code>catch</code> 绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10 提案使我们能够简单的把变量省略掉。</p>
<p>不算大的改动。</p>
<p>之前是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>现在是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-新的基本数据类型BigInt"><a href="#10-新的基本数据类型BigInt" class="headerlink" title="10.新的基本数据类型BigInt"></a>10.新的基本数据类型<code>BigInt</code></h3><p>现在的基本数据类型（值类型）不止5种（ES6之后是六种）了哦！加上BigInt一共有七种基本数据类型，分别是： String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
<p><a href="https://juejin.im/post/5b9cb3336fb9a05d290ee47e" target="_blank" rel="noopener">ES6、ES7、ES8学习指南</a></p>
<blockquote>
<p>作者：上沅兮</p>
<p>链接：<a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank" rel="noopener">https://juejin.im/post/5ca2e1935188254416288eb2</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的使用和理解线程池</title>
    <url>/%E8%BD%AC%E8%BD%BD/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="http://qiniu.mrain22.cn/201904091117_449.png" alt=""></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                   TimeUnit unit, </span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Job());</span><br></pre></td></tr></table></figure>
<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><img src="http://qiniu.mrain22.cn/201904091119_77.png" alt=""></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<p><img src="http://qiniu.mrain22.cn/201904091120_711.png" alt=""></p>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<p><img src="http://qiniu.mrain22.cn/201904091120_865.png" alt=""></p>
<blockquote>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
</blockquote>
<p><img src="http://qiniu.mrain22.cn/201904091123_598.png" alt=""></p>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【&#123;&#125;】"</span>, (end - start));</span><br></pre></td></tr></table></figure>
<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="SpringBoot-使用线程池"><a href="#SpringBoot-使用线程池" class="headerlink" title="SpringBoot 使用线程池"></a>SpringBoot 使用线程池</h2><p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费队列线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(value = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildConsumerQueueThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">"consumer-queue-thread-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),namedThreadFactory,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line"><span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        consumerQueueThreadPool.execute(<span class="keyword">new</span> ConsumerQueueThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<h2 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h2><p>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>
<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>
<p>关于 actuator 就不再细说了，感兴趣的可以看看<a href="http://mp.weixin.qq.com/s?__biz=MzIyMzgyODkxMQ==&amp;mid=2247483762&amp;idx=1&amp;sn=c7c25589c57a826508a6f0f62030c936&amp;chksm=e8190fb2df6e86a4363d0157cb9158a4357732dd730a66c719f13747f038ed05c1abccbd8f9d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">这篇</a>，有详细整理过如何暴露监控端点。</p>
<p>其实 ThreadPool 本身已经提供了不少 api 可以获取线程状态：</p>
<p><img src="http://qiniu.mrain22.cn/201904091125_167.png" alt=""></p>
<p>很多方法看名字就知道其含义，只需要将这些信息暴露到 SpringBoot 的监控端点中，我们就可以在可视化页面查看当前的线程池状态了。</p>
<p>甚至我们可以继承线程池扩展其中的几个函数来自定义监控逻辑：</p>
<p><img src="http://qiniu.mrain22.cn/201904091125_214.png" alt=""></p>
<p><img src="http://qiniu.mrain22.cn/201904091125_224.png" alt=""></p>
<p>看这些名称和定义都知道，这是让子类来实现的。</p>
<p>可以在线程执行前、后、终止状态执行自定义逻辑。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 Hystrix 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:订单服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2018/7/28 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandOrder</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandOrder</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">"OrderGroup"</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"OrderPool"</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"orderName=[&#123;&#125;]"</span>, orderName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OrderName="</span> + orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:用户服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2018/7/28 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandUser</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandUser</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">"UserGroup"</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"UserPool"</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池隔离</span></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"userName=[&#123;&#125;]"</span>, userName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"userName="</span> + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CommandOrder commandPhone = <span class="keyword">new</span> CommandOrder(<span class="string">"手机"</span>);</span><br><span class="line">    CommandOrder command = <span class="keyword">new</span> CommandOrder(<span class="string">"电视"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞方式执行</span></span><br><span class="line">    String execute = commandPhone.execute();</span><br><span class="line">    LOGGER.info(<span class="string">"execute=[&#123;&#125;]"</span>, execute);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步非阻塞方式</span></span><br><span class="line">    Future&lt;String&gt; queue = command.queue();</span><br><span class="line">    String value = queue.get(<span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    LOGGER.info(<span class="string">"value=[&#123;&#125;]"</span>, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CommandUser commandUser = <span class="keyword">new</span> CommandUser(<span class="string">"张三"</span>);</span><br><span class="line">    String name = commandUser.execute();</span><br><span class="line">    LOGGER.info(<span class="string">"name=[&#123;&#125;]"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://qiniu.mrain22.cn/201904091126_640.png" alt=""></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<p><img src="http://qiniu.mrain22.cn/201904091127_556.png" alt=""></p>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code>This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<blockquote>
<p>本文作者： crossoverJie<br>原文链接：<a href="https://mp.weixin.qq.com/s/kbOV0mkE_NMypEQK6rZW3A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kbOV0mkE_NMypEQK6rZW3A</a><br><strong>版权归作者所有，转载请注明出处</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</title>
    <url>/%E8%BD%AC%E8%BD%BD/Java-%E4%B8%AD15%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E7%8B%AC%E4%BA%AB%E9%94%81%EF%BC%8C%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%E7%AD%89%E7%AD%89.html</url>
    <content><![CDATA[<p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p>
<ul>
<li>公平锁 / 非公平锁</li>
<li>可重入锁 / 不可重入锁</li>
<li>独享锁 / 共享锁</li>
<li>互斥锁 / 读写锁</li>
<li>乐观锁 / 悲观锁</li>
<li>分段锁</li>
<li>偏向锁 / 轻量级锁 / 重量级锁</li>
<li>自旋锁</li>
</ul>
<p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p>
<h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 / 非公平锁"></a>公平锁 / 非公平锁</h2><p><strong>公平锁</strong></p>
<ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁。</li>
</ul>
<p><strong>非公平锁</strong></p>
<ul>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</li>
</ul>
<p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 / 不可重入锁"></a>可重入锁 / 不可重入锁</h2><p><strong>可重入锁</strong></p>
<p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p>
<p><strong>不可重入锁</strong></p>
<p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p>
<p><strong>把它变成一个可重入锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”式语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="number">0</span>) &#123;</span><br><span class="line">                state--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p>
<p><strong>ReentrantLock中可重入锁实现</strong></p>
<p>这里看非公平锁的锁获取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是这里</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p>
<h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 / 共享锁"></a>独享锁 / 共享锁</h2><p>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。</p>
<ul>
<li><strong>独享锁</strong>：该锁每一次只能被一个线程所持有。</li>
<li><strong>共享锁</strong>：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</li>
</ul>
<p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于Synchronized而言，当然是独享锁。</p>
<h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁 / 读写锁"></a>互斥锁 / 读写锁</h2><p><strong>互斥锁</strong></p>
<p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p>
<p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源</p>
<p><strong>读写锁</strong></p>
<p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p>
<p><strong>读写锁有三种状态</strong>：读加锁状态、写加锁状态和不加锁状态</p>
<p><strong>读写锁在Java中的具体实现就是</strong><code>ReadWriteLock</code></p>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p>
<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 / 悲观锁"></a>乐观锁 / 悲观锁</h2><p><strong>悲观锁</strong></p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p><strong>乐观锁</strong></p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐<strong>观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的<strong>原子变量类就是使用了乐观锁的一种实现方式CAS实现的</strong>。</p>
<h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p>
<p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p>
<p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p>
<p><strong>我们一般有三种方式降低锁的竞争程度</strong>：<br>1、减少锁的持有时间<br>2、降低锁的请求频率<br>3、使用带有协调机制的独占锁，这些机制允许更高的并发性。</p>
<p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p>
<p><strong>其实说的简单一点就是</strong>：</p>
<p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p>
<h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁 / 轻量级锁 / 重量级锁"></a>偏向锁 / 轻量级锁 / 重量级锁</h2><p><strong>锁的状态</strong>：</p>
<ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<p>锁的状态是通过对象监视器在对象头中的字段来表明的。<br>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<br><strong>这四种状态都不是Java语言中的锁</strong>，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)。</p>
<p><strong>偏向锁</strong></p>
<ul>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
</ul>
<p><strong>轻量级</strong></p>
<ul>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
</ul>
<p><strong>重量级锁</strong></p>
<ul>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁。</p>
<h3 id="简单回顾一下CAS算法"><a href="#简单回顾一下CAS算法" class="headerlink" title="简单回顾一下CAS算法"></a>简单回顾一下CAS算法</h3><p><code>CAS</code>是英文单词<code>Compare and Swap</code>（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h3><p><strong>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</strong>。</p>
<p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。<strong>无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁</strong>。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
<h3 id="Java如何实现自旋锁？"><a href="#Java如何实现自旋锁？" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h3><p>下面是个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p>
<h3 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h3><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。<br>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p>
<h3 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h3><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p>
<h3 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h3><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p>
<p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p>
<p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread cur = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">                cas.compareAndSet(cur, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h3><ul>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li>
</ul>
<h3 id="自旋锁总结"><a href="#自旋锁总结" class="headerlink" title="自旋锁总结"></a>自旋锁总结</h3><ul>
<li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li>
<li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li>
<li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li>
<li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li>
<li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li>
</ul>
<blockquote>
<p>本文作者： 搜云库技术团队<br>原文链接： <a href="https://segmentfault.com/a/1190000017766364" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017766364</a><br><strong>版权归作者所有，转载请注明出处</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松搞懂事务隔离级别</title>
    <url>/%E8%BD%AC%E8%BD%BD/%E8%BD%BB%E6%9D%BE%E6%90%9E%E6%87%82%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html</url>
    <content><![CDATA[<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><p><img src="http://qiniu.mrain22.cn/201904091005_59.png" alt=""></p>
<ul>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性:</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="不可重复度和幻读区别："><a href="#不可重复度和幻读区别：" class="headerlink" title="不可重复度和幻读区别："></a><strong>不可重复度和幻读区别：</strong></h4><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p><strong>例1</strong>（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p><strong>例2</strong>（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<em>可能会导致脏读、幻读或不可重复读。</em></li>
<li><strong>READ-COMMITTED(读取已提交):</strong> 允许读取并发事务已经提交的数据，<em>可以阻止脏读，但是幻读或不可重复读仍有可能发生。</em></li>
<li><strong>REPEATABLE-READ（可重读）:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<em>可以阻止脏读和不可重复读，但幻读仍有可能发生。</em></li>
<li><strong>SERIALIZABLE(可串行化):</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<em>该级别可以防止脏读、不可重复读以及幻读。</em></li>
</ul>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p>
</blockquote>
<h3 id="实际情况演示"><a href="#实际情况演示" class="headerlink" title="实际情况演示"></a>实际情况演示</h3><p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TARNSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<p>•<code>START TARNSACTION</code> |<code>BEGIN</code>:显式地开启一个事务。•<code>COMMIT</code>:提交事务，使得对数据库做的所有修改成为永久性。•<code>ROLLBACK</code> 回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</p>
<p><strong>在下面我会使用 2 个命令行 MySQL ，模拟多线程（多事务）。</strong></p>
<h4 id="脏读-读未提交"><a href="#脏读-读未提交" class="headerlink" title="脏读(读未提交)"></a>脏读(读未提交)</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8xIXqZW7X0t4r6L1rz2fySn4GJDNQKmKXYLWw6xiaEnhLTemyI8gkDFMg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="避免脏读-读已提交"><a href="#避免脏读-读已提交" class="headerlink" title="避免脏读(读已提交)"></a>避免脏读(读已提交)</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8xI1w1ew6rmr64fpl2ldueVgO8nId7PeEwViaibcjejVHlRZCW2floPe9w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8xPO0sKQUAqx3NWriabBicbQzLwYnpBEsULiacFibuibuBe8TC2USy5tKDeOw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8x5kTMec5bOHcdIP0CCoU0BCc1anWNYsUxjT2a5rnblia0GDUS0libaficw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="防止幻读-可重复读"><a href="#防止幻读-可重复读" class="headerlink" title="防止幻读(可重复读)"></a>防止幻读(可重复读)</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8xg1ADPPKhaKfIicKYTTPqkqOIJmM258ZGq3cWStaqHmjWv9nnKcdiaic4w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p>
<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<blockquote>
<p>本文作者： SnailClimb<br>原文链接：<a href="https://mp.weixin.qq.com/s/WhK3SrkMDTj1_o2zp64ArQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WhK3SrkMDTj1_o2zp64ArQ</a><br><strong>版权归作者所有，转载请注明出处</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8中字符串拼接新姿势:StringJoiner</title>
    <url>/%E8%BD%AC%E8%BD%BD/Java-8%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B0%E5%A7%BF%E5%8A%BF-StringJoiner.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>StringJoiner是java.util包中的一个类，用于构造一个由分隔符分隔的字符序列（可选），并且可以从提供的前缀开始并以提供的后缀结尾。虽然这也可以在StringBuilder类的帮助下在每个字符串之后附加分隔符，但StringJoiner提供了简单的方法来实现，而无需编写大量代码。</p>
<p>StringJoiner类共有2个构造函数，5个公有方法。其中最常用的方法就是add方法和toString方法，类似于StringBuilder中的append方法和toString方法。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>StringJoiner的用法比较简单，下面的代码中，我们使用StringJoiner进行了字符串拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringJoinerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">"Hollis"</span>);</span><br><span class="line"></span><br><span class="line">        sj.add(<span class="string">"hollischuang"</span>);</span><br><span class="line">        sj.add(<span class="string">"Java干货"</span>);</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line"></span><br><span class="line">        StringJoiner sj1 = <span class="keyword">new</span> StringJoiner(<span class="string">":"</span>,<span class="string">"["</span>,<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        sj1.add(<span class="string">"Hollis"</span>).add(<span class="string">"hollischuang"</span>).add(<span class="string">"Java干货"</span>);</span><br><span class="line">        System.out.println(sj1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hollischuangHollisJava干货</span><br><span class="line">[Hollis:hollischuang:Java干货]</span><br></pre></td></tr></table></figure>
<p>值得注意的是，当我们<code>StringJoiner(CharSequence delimiter)</code>初始化一个<code>StringJoiner</code>的时候，这个<code>delimiter</code>其实是分隔符，并不是可变字符串的初始值。</p>
<p><code>StringJoiner(CharSequence delimiter,CharSequence prefix,CharSequence suffix)</code>的第二个和第三个参数分别是拼接后的字符串的前缀和后缀。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>介绍了简单的用法之后，我们再来看看这个StringJoiner的原理，看看他到底是如何实现的。主要看一下add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(CharSequence newElement)</span> </span>&#123;</span><br><span class="line">    prepareBuilder().append(newElement);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">prepareBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        value.append(delimiter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> StringBuilder().append(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了一个熟悉的身影——StringBuilder ，没错，StringJoiner其实就是依赖StringBuilder实现的，在之前的文章中我们介绍过StringBuilder的实现原理，本文不在赘述。</p>
<p>当我们发现StringJoiner其实是通过StringBuilder实现之后，我们大概就可以猜到，<strong>他的性能损耗应该和直接使用StringBuilder差不多</strong>！</p>
<h3 id="为什么需要StringJoiner"><a href="#为什么需要StringJoiner" class="headerlink" title="为什么需要StringJoiner"></a>为什么需要StringJoiner</h3><p>在了解了StringJoiner的用法和原理后，可能很多读者就会产生一个疑问，明明已经有一个StringBuilder了，为什么Java 8中还要定义一个StringJoiner呢？到底有什么好处呢？</p>
<p>如果读者足够了解Java 8的话，或许可以猜出个大概，这肯定和Stream有关。</p>
<p>作者也在<a href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html" target="_blank" rel="noopener">Java doc</a>中找到了答案：</p>
<blockquote>
<p>A StringJoiner may be employed to create formatted output from a Stream using Collectors.joining(CharSequence)</p>
</blockquote>
<p>试想，在Java中，如果我们有这样一个List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of(<span class="string">"Hollis"</span>,<span class="string">"hollischuang"</span>,<span class="string">"Java干货"</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想要把他拼接成一个以下形式的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hollis,hollischuang,Java干货</span><br></pre></td></tr></table></figure>
<p>可以通过以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">    builder.append(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, n = list.size(); i &lt; n; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">","</span>).append(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.toString();</span><br></pre></td></tr></table></figure>
<p>还可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().reduce(<span class="keyword">new</span> StringBuilder(), (sb, s) -&gt; sb.append(s).append(<span class="string">','</span>), StringBuilder::append).toString();</span><br></pre></td></tr></table></figure>
<p>但是输出结果稍有些不同，需要进行二次处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hollis,hollischuang,Java干货,</span><br></pre></td></tr></table></figure>
<p>还可以使用”+”进行拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().reduce((a,b)-&gt;a + <span class="string">","</span> + b).toString();</span><br></pre></td></tr></table></figure>
<p>以上几种方式，要么是代码复杂，要么是性能不高，或者无法直接得到想要的结果。</p>
<p>为了满足类似这样的需求，Java 8中提供的StringJoiner就派上用场了。以上需求只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().collect(Collectors.joining(<span class="string">":"</span>))</span><br></pre></td></tr></table></figure>
<p>即可。上面用的表达式中，Collectors.joining的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实现原理就是借助了StringJoiner。</p>
<p>当然，或许在<code>Collector</code>中直接使用<code>StringBuilder</code>似乎也可以实现类似的功能，只不过稍微麻烦一些。所以，Java 8中提供了<code>StringJoiner</code>来丰富<code>Stream</code>的用法。</p>
<p>而且<code>StringJoiner</code>也可以方便的增加前缀和后缀，比如我们希望得到的字符串是<code>[Hollis,hollischuang,Java干货]</code>而不是<code>Hollis,hollischuang,Java</code>干货的话，StringJoiner的优势就更加明显了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了Java 8中提供的可变字符串类——<code>StringJoiner</code>，可以用于字符串拼接。</p>
<p><code>StringJoiner</code>其实是通过<code>StringBuilder</code>实现的，所以他的性能和<code>StringBuilder</code>差不多，他也是<code>非线程安全</code>的。</p>
<p>如果日常开发中中，需要进行字符串拼接，如何选择？</p>
<p>1、如果只是简单的字符串拼接，考虑直接使用<code>+</code>即可。</p>
<p>2、如果是在<code>for循环</code>中进行字符串拼接，考虑使用<code>StringBuilder</code>和<code>StringBuffer</code>。</p>
<p>3、如果是通过一个<code>List</code>进行字符串拼接，则考虑使用<code>StringJoiner</code>。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符串拼接的实现原理(append,concat,+,StringUtils.join)</title>
    <url>/%E8%BD%AC%E8%BD%BD/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-append-concat-StringUtils-join.html</url>
    <content><![CDATA[<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串拼接是我们在Java代码中比较经常要做的事情，就是把多个字符串拼接到一起。</p>
<p>我们都知道，<strong>String是Java中一个不可变的类</strong>，所以他一旦被实例化就无法被修改。</p>
<blockquote>
<p>不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，比如可以缓存hashcode、使用更加便利以及更加安全等。</p>
</blockquote>
<p>但是，既然字符串是不可变的，那么字符串拼接又是怎么回事呢？</p>
<p><strong>字符串不变性与字符串拼接</strong></p>
<p>其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。下面一段字符串拼接代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abcd"</span>;</span><br><span class="line">s = s.concat(<span class="string">"ef"</span>);</span><br></pre></td></tr></table></figure>
<p>其实最后我们得到的<code>s</code>已经是一个新的字符串了。如下图</p>
<p><img src="http://qiniu.mrain22.cn/201903250917_507.png" alt=""></p>
<p>s中保存的是一个重新创建出来的String对象的引用。</p>
<p>那么，在Java中，到底如何进行字符串拼接呢？字符串拼接有很多种方式，这里简单介绍几种比较常用的。</p>
<p><strong>使用+拼接字符串</strong></p>
<p>在Java中，拼接字符串最简单的方式就是直接使用符号<code>+</code>来拼接。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat + <span class="string">","</span> + introduce;</span><br></pre></td></tr></table></figure>
<p>这里要特别说明一点，有人把Java中使用<code>+</code>拼接字符串的功能理解为<strong>运算符重载</strong>。其实并不是，<strong>Java是不支持运算符重载的</strong>。这其实只是Java提供的一个<strong>语法糖</strong>。后面再详细介绍。</p>
<blockquote>
<p>运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p>
<p>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p>
</blockquote>
<p><strong>concat</strong><br>除了使用<code>+</code>拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat.concat(<span class="string">","</span>).concat(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringBuffer</strong></p>
<p>关于字符串，Java中除了定义了一个可以用来定义<strong>字符串常量</strong>的<code>String</code>类以外，还提供了可以用来定义<strong>字符串变量</strong>的<code>StringBuffer</code>类，它的对象是可以扩充和修改的。</p>
<p>使用<code>StringBuffer</code>可以方便的对字符串进行拼接。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer wechat = <span class="keyword">new</span> StringBuffer(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuffer hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringBuilder</strong><br>除了<code>StringBuffer</code>以外，还有一个类<code>StringBuilder</code>也可以使用，其用法和<code>StringBuffer</code>类似。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder wechat = <span class="keyword">new</span> StringBuilder(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuilder hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringUtils.join</strong><br>除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如<code>apache.commons中</code>提供的<code>StringUtils</code>类，其中的<code>join</code>方法可以拼接字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">System.out.println(StringUtils.join(wechat, <span class="string">","</span>, introduce));</span><br></pre></td></tr></table></figure>
<p>这里简单说一下，StringUtils中提供的join方法，最主要的功能是：将数组或集合以某拼接符拼接到一起形成新的字符串，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String []list  =&#123;&quot;Hollis&quot;,&quot;每日更新Java相关技术文章&quot;&#125;;</span><br><span class="line">String result= StringUtils.join(list,&quot;,&quot;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">//结果：Hollis,每日更新Java相关技术文章</span><br></pre></td></tr></table></figure>
<p>并且，Java8中的String类中也提供了一个静态的join方法，用法和StringUtils.join类似。</p>
<p>以上就是比较常用的五种在Java种拼接字符串的方式，那么到底哪种更好用呢？为什么阿里巴巴Java开发手册中不建议在循环体中使用<code>+</code>进行字符串拼接呢？</p>
<p><img src="http://qiniu.mrain22.cn/201903250919_383.png" alt=""></p>
<p>(阿里巴巴Java开发手册中关于字符串拼接的规约)</p>
<h3 id="使用-拼接字符串的实现原理"><a href="#使用-拼接字符串的实现原理" class="headerlink" title="使用+拼接字符串的实现原理"></a>使用<code>+</code>拼接字符串的实现原理</h3><p>前面提到过，使用<code>+</code>拼接字符串，其实只是Java提供的一个语法糖， 那么，我们就来解一解这个语法糖，看看他的内部原理到底是如何实现的。</p>
<p>还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat + <span class="string">","</span> + introduce;</span><br></pre></td></tr></table></figure>
<p>反编译后的内容如下，反编译工具为jad。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0"</span>;<span class="comment">//每日更新Java相关技术文章</span></span><br><span class="line">String hollis = (<span class="keyword">new</span> StringBuilder()).append(wechat).append(<span class="string">","</span>).append(introduce).toString();</span><br></pre></td></tr></table></figure>
<p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。</p>
<p>那么也就是说，Java中的<code>+</code>对字符串的拼接，其实现原理是使用<code>StringBuilder.append</code>。</p>
<h3 id="concat是如何实现的"><a href="#concat是如何实现的" class="headerlink" title="concat是如何实现的"></a>concat是如何实现的</h3><p>我们再来看一下concat方法的源代码，看一下这个方法又是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。</p>
<p>通过源码我们也可以看到，经过concat方法，其实是new了一个新的String，这也就呼应到前面我们说的字符串的不变性问题上了。</p>
<h3 id="StringBuffer和StringBuilder的实现"><a href="#StringBuffer和StringBuilder的实现" class="headerlink" title="StringBuffer和StringBuilder的实现"></a>StringBuffer和StringBuilder的实现</h3><p>接下来我们看看<code>StringBuffer</code>和<code>StringBuilder</code>的实现原理。</p>
<p>和<code>String</code>类类似，<code>StringBuilder</code>类也封装了一个字符数组，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
<p>与<code>String</code>不同的是，它并不是<code>final</code>的，所以他是可以修改的。另外，与<code>String</code>不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>其append源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类继承了<code>AbstractStringBuilder</code>类，看下其<code>append</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p>
<p><code>StringBuffer</code>和<code>StringBuilder</code>类似，最大的区别就是<code>StringBuffer</code>是线程安全的，看一下<code>StringBuffer</code>的<code>append</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用<code>synchronized</code>进行声明，说明是一个线程安全的方法。而<code>StringBuilder</code>则不是线程安全的。</p>
<h3 id="StringUtils-join是如何实现的"><a href="#StringUtils-join是如何实现的" class="headerlink" title="StringUtils.join是如何实现的"></a>StringUtils.join是如何实现的</h3><p>通过查看<code>StringUtils.join</code>的源代码，我们可以发现，其实他也是通过<code>StringBuilder</code>来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(<span class="keyword">final</span> Object[] array, String separator, <span class="keyword">final</span> <span class="keyword">int</span> startIndex, <span class="keyword">final</span> <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (separator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// endIndex - startIndex &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))</span></span><br><span class="line">    <span class="comment">//           (Assuming that all Strings are roughly equally long)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> noOfItems = endIndex - startIndex;</span><br><span class="line">    <span class="keyword">if</span> (noOfItems &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StringBuilder buf = <span class="keyword">new</span> StringBuilder(noOfItems * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex) &#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h3><p>既然有这么多种字符串拼接的方法，那么到底哪一种效率最高呢？我们来简单对比一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//这里是初始字符串定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//这里是字符串拼接代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"cost:"</span> + (t2 - t1));</span><br></pre></td></tr></table></figure>
<p>我们使用形如以上形式的代码，分别测试下五种字符串拼接代码的运行时间。得到结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+ cost:<span class="number">5119</span></span><br><span class="line">StringBuilder cost:<span class="number">3</span></span><br><span class="line">StringBuffer cost:<span class="number">4</span></span><br><span class="line">concat cost:<span class="number">3623</span></span><br><span class="line">StringUtils.join cost:<span class="number">25726</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，用时从短到长的对比是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder`&lt;`StringBuffer`&lt;`concat`&lt;`+`&lt;`StringUtils.join</span><br></pre></td></tr></table></figure>
<p><code>StringBuffer</code>在<code>StringBuilder</code>的基础上，做了同步处理，所以在耗时上会相对多一些。</p>
<p>StringUtils.join也是使用了StringBuilder，并且其中还是有很多其他操作，所以耗时较长，这个也容易理解。其实StringUtils.join更擅长处理字符串数组或者列表的拼接。</p>
<p>那么问题来了，前面我们分析过，其实使用<code>+</code>拼接字符串的实现原理也是使用的<code>StringBuilder</code>，那为什么结果相差这么多，高达1000多倍呢？</p>
<p>我们再把以下代码反编译下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str += s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"+ cost:"</span> + (t2 - t1));</span><br></pre></td></tr></table></figure>
<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str = (<span class="keyword">new</span> StringBuilder()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">new</span> StringBuilder()).append(<span class="string">"+ cost:"</span>).append(t2 - t1).toString());</span><br></pre></td></tr></table></figure>
<p>我们可以看到，反编译后的代码，在<code>for</code>循环中，每次都是<code>new</code>了一个<code>StringBuilder</code>，然后再把<code>String</code>转成<code>StringBuilder</code>，再进行<code>append</code>。</p>
<p>而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。</p>
<p>所以，阿里巴巴Java开发手册建议：循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。而不要使用<code>+</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了什么是字符串拼接，虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。</p>
<p>常用的字符串拼接方式有五种，分别是使用<code>+</code>、使用<code>concat</code>、使用<code>StringBuilder</code>、使用<code>StringBuffer</code>以及使用<code>StringUtils.join</code>。</p>
<p>由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。</p>
<p>因此，经过对比，我们发现，直接使用<code>StringBuilder</code>的方式是效率最高的。因为<code>StringBuilder</code>天生就是设计来定义可变字符串和字符串的变化操作的。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring零配置之@Configuration注解详解</title>
    <url>/%E8%BD%AC%E8%BD%BD/Spring%E9%9B%B6%E9%85%8D%E7%BD%AE%E4%B9%8B@Configuration%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h3 id="Configuration介绍"><a href="#Configuration介绍" class="headerlink" title="@Configuration介绍"></a>@Configuration介绍</h3><blockquote>
<p>Spring3.0之前要使用Spring必须要有一个xml配置文件，这也是Spring的核心文件，而Spring3.0之后可以不要配置文件了，通过注解@Configuration完全搞定。</p>
<p><img src="http://qiniu.mrain22.cn/201903161641_996.png" alt=""></p>
<p>@Configuration即用来代替Spring配置文件的，它就是一个@Component组件，接收一个value值也就是bean的名字，value可以不填。</p>
</blockquote>
<h3 id="Configuration使用"><a href="#Configuration使用" class="headerlink" title="@Configuration使用"></a>@Configuration使用</h3><blockquote>
<p>下面是一个使用实例，创建了一个userService和accountService的实例，accountService实例引用userService实例。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.mrain22.web"</span>&#125;)</span><br><span class="line"><span class="meta">@Import</span>(UserConfg.class)</span><br><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:config/spring-beans.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfg</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"userService"</span>, initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line">	<span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AccountService <span class="title">accountService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">		AccountService as = <span class="keyword">new</span> AccountService();</span><br><span class="line">		as.setUserService(userService);</span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注解说明</p>
<p>@Configuration：代表这个类是一个配置类。</p>
<p>@ComponentScan：用来扫描指定包下面的注解类。</p>
<p>@Import：用来导入其他的@Configuration配置类。</p>
<p>@ImportResource：用来导入xml配置文件，比如某些配置一定要xml配置。</p>
<p>@Bean：用来定义一个bean，可以指定初始、销毁方法，及bean范围等。</p>
</blockquote>
<p>这些注解都在spring-context包下，还有其他注解用来解放xml形式的配置，大量xml配置可java配置化，只要定义好，Spring会自动扫描包下面的@Configuration注解的配置文件类来装配。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>获取Spring的ApplicationContext的几种方式</title>
    <url>/%E8%BD%AC%E8%BD%BD/%E8%8E%B7%E5%8F%96Spring%E7%9A%84ApplicationContext%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="Application-Context定义"><a href="#Application-Context定义" class="headerlink" title="Application Context定义"></a>Application Context定义</h3><blockquote>
<p>简单来说就是Spring中的高级容器，可以获取容器中的各种bean组件，注册监听事件，加载资源文件等功能。</p>
</blockquote>
<h3 id="Application-Context获取的几种方式"><a href="#Application-Context获取的几种方式" class="headerlink" title="Application Context获取的几种方式"></a>Application Context获取的几种方式</h3><h4 id="1、直接注入"><a href="#1、直接注入" class="headerlink" title="1、直接注入"></a>1、直接注入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext ctx;</span><br></pre></td></tr></table></figure>
<h4 id="2、实现ApplicationContextAware接口（推荐）"><a href="#2、实现ApplicationContextAware接口（推荐）" class="headerlink" title="2、实现ApplicationContextAware接口（推荐）"></a>2、实现ApplicationContextAware接口（推荐）</h4><p><img src="http://qiniu.mrain22.cn/201903161607_1.png" alt=""></p>
<h4 id="3、WebApplicationContextUtils工具类"><a href="#3、WebApplicationContextUtils工具类" class="headerlink" title="3、WebApplicationContextUtils工具类"></a>3、WebApplicationContextUtils工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(request.getSession().getServletContext());</span><br></pre></td></tr></table></figure>
<h4 id="4、从当前线程绑定获取（Spring-boot不支持）"><a href="#4、从当前线程绑定获取（Spring-boot不支持）" class="headerlink" title="4、从当前线程绑定获取（Spring boot不支持）"></a>4、从当前线程绑定获取（Spring boot不支持）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的各种Utils(二)：PropertiesLoaderUtils详解</title>
    <url>/Spring%E7%B3%BB%E5%88%97/Spring%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DUtils-%E4%BA%8C-%EF%BC%9APropertiesLoaderUtils%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<p>今天介绍的是PropertiesLoaderUtils，这个工具类主要是针对Properties文件的加载操作，在Spring对.properties文件和.factories文件的操作都有使用到。</p>
<p>先来简单看看这个类提供的有用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从一个资源文件加载Properties；</span></span><br><span class="line"><span class="function">Properties <span class="title">loadProperties</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载资源文件，传入的是提供了编码的资源类（EncodedResource）；和上面方法基本一致；</span></span><br><span class="line"><span class="function">Properties <span class="title">loadProperties</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从一个资源类中加载资源，并填充到指定的Properties对象中；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillProperties</span><span class="params">(Properties props, Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从一个编码资源类中加载资源，并填充到指定的Properties对象中；和上面方法基本一致；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillProperties</span><span class="params">(Properties props, EncodedResource resource)</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据资源文件名称，加载并合并classpath中的所有资源文件；</span></span><br><span class="line"><span class="function">Properties <span class="title">loadAllProperties</span><span class="params">(String resourceName)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的ClassLoader中，根据资源文件名称，加载并合并classpath中的所有资源文件；</span></span><br><span class="line"><span class="function">Properties <span class="title">loadAllProperties</span><span class="params">(String resourceName, ClassLoader classLoader)</span> <span class="keyword">throws</span> IOException；</span></span><br></pre></td></tr></table></figure>
<h2 id="loadProperties"><a href="#loadProperties" class="headerlink" title="loadProperties"></a>loadProperties</h2><p>测试方法很简单，我们首先准备一个test.properties文件，放到resources下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#test.properties</span><br><span class="line">key=value</span><br><span class="line">key2=中文</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadPropertiesResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties ret = PropertiesLoaderUtils</span><br><span class="line">            .loadProperties(<span class="keyword">new</span> ClassPathResource(<span class="string">"test.properties"</span>));</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key"</span>));</span><br><span class="line">    assertEquals(<span class="string">"中文"</span>, ret.getProperty(<span class="string">"key2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试完成。没有太大难度；<br>但是，其实Properties对象不仅仅支持.properties文件，还支持XML格式的资源配置文件。</p>
<p>那么我们就可以有以下测试。创建一个text.xml文件在classpath下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comment</span>&gt;</span>一些自定义说明<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key2"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadPropertiesResourceXml</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties ret = PropertiesLoaderUtils</span><br><span class="line">            .loadProperties(<span class="keyword">new</span> ClassPathResource(<span class="string">"test.xml"</span>));</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key"</span>));</span><br><span class="line">    assertEquals(<span class="string">"中文"</span>, ret.getProperty(<span class="string">"key2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过。当然，我们是非常不建议使用XML的方式来做配置的。</p>
<p>接下来使用EncodeResource来测试，EncodeResource在Resource上增加了字符编码设置。同样使用之前的test.properties：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadPropertiesEncodedResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties ret = PropertiesLoaderUtils.loadProperties(</span><br><span class="line">            <span class="keyword">new</span> EncodedResource(<span class="keyword">new</span> ClassPathResource(<span class="string">"test.properties"</span>),</span><br><span class="line">                    <span class="string">"UTF-8"</span>));</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key"</span>));</span><br><span class="line">    assertEquals(<span class="string">"中文"</span>, ret.getProperty(<span class="string">"key2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，只是在之前的ClassPathResource基础之上包装了UTF-8字符编码的EncodeResource；</p>
<h2 id="loadAllProperties"><a href="#loadAllProperties" class="headerlink" title="loadAllProperties"></a>loadAllProperties</h2><p>loadProperties方法，是从当前classpath下加载properties文件，如果使用loadAllProperties，可以从当前classpath下加载所有的相同名称的properties文件，并执行合并。</p>
<p>来完成一个测试。把上一个例子中的test.properties文件保留，放到src/main/resources中；然后在src/test/resources目录下再创建一个test.properties文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key3=value</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadAllPropertiesString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties ret = PropertiesLoaderUtils</span><br><span class="line">            .loadAllProperties(<span class="string">"test.properties"</span>);</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key"</span>));</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key3"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试通过；可以看到，main下的test.properties和test下的test.properties都被识别并执行了合并；</p>
<p>那如果在test/resources中的test.properties中增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key=update</span><br></pre></td></tr></table></figure>
<p>再次执行测试，仍然通过。</p>
<p>说明在多个配置文件中如果有重复key，以最近的classpath为准（比如当前应用的properties内容会优先于jar包中的properties）。</p>
<p>但是，如果这种情况下，使用loadProperties方法，那么只会加载到test/resources中的test.properties；</p>
<h2 id="fillProperties"><a href="#fillProperties" class="headerlink" title="fillProperties"></a>fillProperties</h2><p>fillProperties方法其实是loadProperties方法的真正调用方法。先来看看测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillPropertiesPropertiesResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"test.properties"</span>);</span><br><span class="line">    Properties ret = <span class="keyword">new</span> Properties();</span><br><span class="line">    PropertiesLoaderUtils.fillProperties(ret, res);</span><br><span class="line">    assertEquals(<span class="string">"value"</span>, ret.getProperty(<span class="string">"key"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用非常简单。</p>
<p>我们来看一下loadProperties方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">loadProperties</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    fillProperties(props, resource);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实调用的就是fileProperties方法，而这个方法的实现其实也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillProperties</span><span class="params">(Properties props, EncodedResource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    fillProperties(props, resource, <span class="keyword">new</span> DefaultPropertiesPersister());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理给了fillProperties(Properties props, EncodedResource resource, PropertiesPersister persister)方法；只是最后一个参数是一个PropertiesPersister，抽取了一个统一的从XML或者properties资源加载和装载接口；来看看具体实现（我只保留了最基本的关键代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillProperties</span><span class="params">(Properties props, EncodedResource resource, PropertiesPersister persister)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputStream stream = <span class="keyword">null</span>;</span><br><span class="line">    Reader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String filename = resource.getResource().getFilename();</span><br><span class="line">        <span class="comment">//如果是XML文件，</span></span><br><span class="line">        <span class="keyword">if</span> (filename != <span class="keyword">null</span> &amp;&amp; filename.endsWith(XML_FILE_EXTENSION)) &#123;</span><br><span class="line">            stream = resource.getInputStream();</span><br><span class="line">            persister.loadFromXml(props, stream);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            stream = resource.getInputStream();</span><br><span class="line">            persister.load(props, stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//close方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实就是调用了PropertiesPersister的loadFromXml和load方法来分别加载XML或properties；</p>
<p>有兴趣的童鞋可以看看DefaultPropertiesPersister的相关的这两个方法，其实核心还是使用Properties对象的load和loadFromXML方法完成的。</p>
]]></content>
      <categories>
        <category>Spring系列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Utils的使用系列（一）：StringUtils</title>
    <url>/Spring%E7%B3%BB%E5%88%97/Spring%E4%B8%ADUtils%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AStringUtils.html</url>
    <content><![CDATA[<p>在Spring中，有非常多Utils工具类，这些工具类有的是为了开发者使用的，有的只是提供给Spring框架使用的。了解这些工具类，在适当的时候使用这些工具类，对我们平时的开发还是很有帮助的，能极大方便我们的开发。</p>
<p>Spring的工具类都是以Utils结尾，所以要查看这些工具类，只需要在API文档中查询所有*Utils即可，可以看到有多达几十个。在后面的几篇文章中我会选择几个常用的Utils，给大家展示一下Spring中的工具类的有用和常用方法。</p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>属于该组的方法都是在对字符串进行一些判定操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean isEmpty(Object str):字符串是否为空或者空字符串：""</span></span><br><span class="line"><span class="comment">// boolean hasLength(CharSequence str):字符串是否为空，或者长度为0</span></span><br><span class="line"><span class="comment">// boolean hasText(String str):字符串是否有内容（不为空，且不全为空格）</span></span><br><span class="line">assertFalse(StringUtils.hasText(<span class="string">"   "</span>));</span><br><span class="line"><span class="comment">// boolean containsWhitespace(String str):字符串是否包含空格</span></span><br><span class="line">assertTrue(StringUtils.containsWhitespace(<span class="string">"a b"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="字符串头尾操作"><a href="#字符串头尾操作" class="headerlink" title="字符串头尾操作"></a>字符串头尾操作</h2><p>属于该类别的方法，都是对字符串前，或者字符串后的内容进行判定或者操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串头尾操作</span></span><br><span class="line"><span class="comment">// String trimWhitespace(String str):去掉字符串前后的空格</span></span><br><span class="line">assertEquals(<span class="string">"abc"</span>, StringUtils.trimWhitespace(<span class="string">" abc "</span>));</span><br><span class="line"><span class="comment">// String trimAllWhitespace(String str):去掉字符串中所有的空格</span></span><br><span class="line">assertEquals(<span class="string">"abc"</span>, StringUtils.trimAllWhitespace(<span class="string">" a b c "</span>));</span><br><span class="line"><span class="comment">// String trimLeadingWhitespace(String str):去掉字符串开头的空格</span></span><br><span class="line"><span class="comment">// String trimTrailingWhitespace(String str):去掉字符串结束的空格</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// String trimLeadingCharacter(String str, char leadingCharacter):去掉字符串开头的指定字符；</span></span><br><span class="line"><span class="comment">// String trimTrailingCharacter(String str, char trailingCharacter):去掉字符串结尾的指定字符；</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// boolean startsWithIgnoreCase(String str, String prefix):</span></span><br><span class="line"><span class="comment">// 判断字符串是否以指定字符串开头，忽略大小写</span></span><br><span class="line">assertTrue(StringUtils.startsWithIgnoreCase(<span class="string">"abcd"</span>, <span class="string">"AB"</span>));</span><br><span class="line"><span class="comment">// boolean endsWithIgnoreCase(String str, String suffix):</span></span><br><span class="line"><span class="comment">// 判断字符串是否以指定字符串结尾，忽略大小写</span></span><br></pre></td></tr></table></figure>
<h2 id="文件路径名称相关操作"><a href="#文件路径名称相关操作" class="headerlink" title="文件路径名称相关操作"></a>文件路径名称相关操作</h2><p>文件路径名称相关操作，是针对文件名，文件路径，文件后缀等常见文件操作中需要用到的方法进行封装；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String unqualify(String qualifiedName):</span></span><br><span class="line"><span class="comment">// 得到以.分割的最后一个值，可以非常方便的获取类似类名或者文件后缀</span></span><br><span class="line">assertEquals(<span class="string">"java"</span>, StringUtils.unqualify(<span class="string">"cn.wolfcode.java"</span>));</span><br><span class="line">assertEquals(<span class="string">"java"</span>, StringUtils.unqualify(<span class="string">"cn/wolfcode/Hello.java"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String unqualify(String qualifiedName, char separator):</span></span><br><span class="line"><span class="comment">// 得到以给定字符分割的最后一个值，可以非常方便的获取类似文件名</span></span><br><span class="line">assertEquals(<span class="string">"Hello.java"</span>, StringUtils</span><br><span class="line">        .unqualify(<span class="string">"cn/wolfcode/Hello.java"</span>, File.separatorChar));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String capitalize(String str):首字母大写</span></span><br><span class="line">assertEquals(<span class="string">"Wolfcode"</span>, StringUtils.capitalize(<span class="string">"wolfcode"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String uncapitalize(String str):取消首字母大写</span></span><br><span class="line">assertEquals(<span class="string">"java"</span>, StringUtils.uncapitalize(<span class="string">"Java"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String getFilename(String path):获取文件名,就不需要再使用FilenameUtils</span></span><br><span class="line">assertEquals(<span class="string">"myfile.txt"</span>,</span><br><span class="line">        StringUtils.getFilename(<span class="string">"mypath/myfile.txt"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String getFilenameExtension(String path):获取文件后缀名</span></span><br><span class="line">assertEquals(<span class="string">"txt"</span>,</span><br><span class="line">        StringUtils.getFilenameExtension(<span class="string">"mypath/myfile.txt"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String stripFilenameExtension(String path):截取掉文件路径后缀</span></span><br><span class="line">assertEquals(<span class="string">"mypath/myfile"</span>,</span><br><span class="line">        StringUtils.stripFilenameExtension(<span class="string">"mypath/myfile.txt"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String applyRelativePath(String path, String relativePath):</span></span><br><span class="line"><span class="comment">// 找到给定的文件，和另一个相对路径的文件，返回第二个文件的全路径</span></span><br><span class="line"><span class="comment">// 打印：d:/java/wolfcode/other/Some.java</span></span><br><span class="line">System.out.println(StringUtils.applyRelativePath(</span><br><span class="line">        <span class="string">"d:/java/wolfcode/Test.java"</span>, <span class="string">"other/Some.java"</span>));</span><br><span class="line"><span class="comment">// 但是不支持重新定位绝对路径和上级目录等复杂一些的相对路径写法：</span></span><br><span class="line"><span class="comment">// 仍然打印：d:/java/wolfcode/../other/Some.java</span></span><br><span class="line">System.out.println(StringUtils.applyRelativePath(</span><br><span class="line">        <span class="string">"d:/java/wolfcode/Test.java"</span>, <span class="string">"../other/Some.java"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String cleanPath(String path):</span></span><br><span class="line"><span class="comment">// 清理文件路径,这个方法配合applyRelativePath就可以计算一些简单的相对路径了</span></span><br><span class="line"><span class="comment">// 打印:d:/java/other/Some.java</span></span><br><span class="line">System.out.println(</span><br><span class="line">        StringUtils.cleanPath(<span class="string">"d:/java/wolfcode/../other/Some.java"</span>));</span><br><span class="line"><span class="comment">// 需求：获取d:/java/wolfcode/Test.java相对路径为../../other/Some.java的文件全路径：</span></span><br><span class="line"><span class="comment">// 打印：d:/other/Some.java</span></span><br><span class="line">System.out.println(StringUtils.cleanPath(StringUtils.applyRelativePath(</span><br><span class="line">        <span class="string">"d:/java/wolfcode/Test.java"</span>, <span class="string">"../../other/Some.java"</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// boolean pathEquals(String path1, String path2):</span></span><br><span class="line"><span class="comment">// 判断两个文件路径是否相同，会先执行cleanPath之后再比较</span></span><br><span class="line">assertTrue(StringUtils.pathEquals(<span class="string">"d:/wolfcode.txt"</span>,</span><br><span class="line">        <span class="string">"d:/somefile/../wolfcode.txt"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="字符串和子串的操作"><a href="#字符串和子串的操作" class="headerlink" title="字符串和子串的操作"></a>字符串和子串的操作</h2><p>该组方法中主要是提供了字符串和字符串子串的操作，比如子串的匹配，子串的替换；子串的删除等等操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean substringMatch(CharSequence str, int index, CharSequence</span></span><br><span class="line"><span class="comment">// substring):判断从指定索引开始，是否匹配子字符串</span></span><br><span class="line">assertTrue(StringUtils.substringMatch(<span class="string">"aabbccdd"</span>, <span class="number">1</span>, <span class="string">"abb"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// int countOccurrencesOf(String str, String sub):判断子字符串在字符串中出现的次数</span></span><br><span class="line">assertEquals(<span class="number">4</span>, StringUtils.countOccurrencesOf(<span class="string">"ababaabab"</span>, <span class="string">"ab"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String replace(String inString, String oldPattern, String</span></span><br><span class="line"><span class="comment">// newPattern):在字符串中使用子字符串替换</span></span><br><span class="line">assertEquals(<span class="string">"cdcdacdcd"</span>, StringUtils.replace(<span class="string">"ababaabab"</span>, <span class="string">"ab"</span>, <span class="string">"cd"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String delete(String inString, String pattern):删除所有匹配的子字符串；</span></span><br><span class="line">assertEquals(<span class="string">"a"</span>, StringUtils.delete(<span class="string">"ababaabab"</span>, <span class="string">"ab"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String deleteAny(String inString, String charsToDelete):删除子字符串中任意出现的字符</span></span><br><span class="line">assertEquals(<span class="string">""</span>, StringUtils.deleteAny(<span class="string">"ababaabab"</span>, <span class="string">"bar"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String quote(String str) :在字符串前后增加单引号,比较适合在日志时候使用；</span></span><br><span class="line">assertEquals(<span class="string">"'hello'"</span>, StringUtils.quote(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="本地化相关"><a href="#本地化相关" class="headerlink" title="本地化相关"></a>本地化相关</h2><p>和Locale相关的一些字符串操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locale parseLocaleString(String localeString):</span></span><br><span class="line"><span class="comment">// 从本地化字符串中解析出本地化信息，相当于Locale.toString()的逆向方法</span></span><br><span class="line">assertEquals(Locale.CHINA, StringUtils.parseLocaleString(<span class="string">"zh_CN"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String toLanguageTag(Locale locale):把Locale转化成HTTP中Accept-Language能接受的本地化标准；</span></span><br><span class="line"><span class="comment">// 比如标准的本地化字符串为：zh_CN，更改为zh-CN</span></span><br><span class="line">System.out.println(StringUtils</span><br><span class="line">        .toLanguageTag(StringUtils.parseLocaleString(<span class="string">"zh_CN"</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="字符串和Properties"><a href="#字符串和Properties" class="headerlink" title="字符串和Properties"></a>字符串和Properties</h2><p>把字符串和Properties对象之间的相互转化抽取出的一些常用方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Properties splitArrayElementsIntoProperties(String[] array, String delimiter):</span></span><br><span class="line"><span class="comment">// 把字符串数组中的每一个字符串按照给定的分隔符装配到一个Properties中</span></span><br><span class="line">String[] strs=<span class="keyword">new</span> String[]&#123;<span class="string">"key:value"</span>,<span class="string">"key2:中文"</span>&#125;;</span><br><span class="line">Properties ps=StringUtils.splitArrayElementsIntoProperties(strs, <span class="string">":"</span>);</span><br><span class="line"><span class="comment">//打印输出：&#123;key=value, key2=中文&#125;</span></span><br><span class="line">System.out.println(ps);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)</span></span><br><span class="line"><span class="comment">//把字符串数组中的每一个字符串按照给定的分隔符装配到一个Properties中,并删除指定字符串，比如括号之类的；</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串和数组之间的基本操作"><a href="#字符串和数组之间的基本操作" class="headerlink" title="字符串和数组之间的基本操作"></a>字符串和数组之间的基本操作</h2><p>该组方法主要是完成字符串和字符串数组之间的基本操作，比如追加，删除，排序等；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String[] addStringToArray(String[] array, String str):把一个字符串添加到一个字符串数组中</span></span><br><span class="line"><span class="comment">// 打印：[a, b, c, d]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils</span><br><span class="line">        .addStringToArray(<span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;, <span class="string">"d"</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String[] concatenateStringArrays(String[] array1, String[]array2):连接两个字符串数组</span></span><br><span class="line"><span class="comment">//打印：[a, b, c, a, b, c]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.concatenateStringArrays(</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span> &#125;)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] mergeStringArrays(String[] array1, String[] array2)：连接两个字符串数组，去掉重复元素</span></span><br><span class="line"><span class="comment">//打印：[a, b, c, d]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.mergeStringArrays(</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span> &#125;)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] sortStringArray(String[] array):字符串数组排序</span></span><br><span class="line"><span class="comment">//打印：[a, b, c, d]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.sortStringArray(<span class="keyword">new</span> String[]&#123;<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>&#125;)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] toStringArray(Collection&lt;String&gt; collection):把字符串集合变成字符串数组</span></span><br><span class="line"><span class="comment">//String[] toStringArray(Enumeration&lt;String&gt; enumeration):把字符串枚举类型变成字符串数组</span></span><br><span class="line"><span class="comment">//String[] trimArrayElements(String[] array):把字符串数组中所有字符串执行trim功能；</span></span><br><span class="line"><span class="comment">//String[] removeDuplicateStrings(String[] array):去掉给定字符串数组中重复的元素，能保持原顺序；</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串和数组的更多方法"><a href="#字符串和数组的更多方法" class="headerlink" title="字符串和数组的更多方法"></a>字符串和数组的更多方法</h2><p>在该组方法中，提供了更多字符串和数组的方法，主要涉及到字符串数组的合并，字符串的按规则拆分，字符串和集合之间的相互转化等操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String[] split(String toSplit, String delimiter):按照指定字符串分割字符串；</span></span><br><span class="line">assertArrayEquals(<span class="keyword">new</span> String[]&#123;<span class="string">"wolfcode"</span>,<span class="string">"cn"</span>&#125;, StringUtils.split(<span class="string">"wolfcode.cn"</span>, <span class="string">"."</span>));</span><br><span class="line"><span class="comment">//只分割第一次，打印：[www, wolfcode.cn]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.split(<span class="string">"www.wolfcode.cn"</span>, <span class="string">"."</span>)));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] tokenizeToStringArray(String str, String delimiters)</span></span><br><span class="line"><span class="comment">//会对每一个元素执行trim操作，并去掉空字符串</span></span><br><span class="line"><span class="comment">//使用的是StringTokenizer完成，</span></span><br><span class="line"><span class="comment">//打印[b, c, d]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.tokenizeToStringArray(<span class="string">"aa,ba,ca,da"</span>, <span class="string">"a,"</span>)));</span><br><span class="line"><span class="comment">//String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)</span></span><br><span class="line"><span class="comment">//后面两个参数在限定是否对每一个元素执行trim操作，是否去掉空字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] delimitedListToStringArray(String str, String delimiter):分割字符串，会把delimiter作为整体分隔符</span></span><br><span class="line"><span class="comment">//打印：[a, b, c, da]</span></span><br><span class="line">System.out.println(Arrays.toString(StringUtils.delimitedListToStringArray(<span class="string">"aa,ba,ca,da"</span>, <span class="string">"a,"</span>)));</span><br><span class="line"><span class="comment">//String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)</span></span><br><span class="line"><span class="comment">//分割字符串，会把delimiter作为整体分隔符，增加一个要从分割字符串中删除的字符；</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//String[] commaDelimitedListToStringArray(String str):使用逗号分割字符串</span></span><br><span class="line"><span class="comment">//是delimitedListToStringArray(str, ",")的简单方法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Set&lt;String&gt; commaDelimitedListToSet(String str)：使用逗号分割字符串，并放到set中去重</span></span><br><span class="line"><span class="comment">//使用LinkedHashSet;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//String collectionToDelimitedString(Collection&lt;?&gt; coll, String delim, String prefix, String suffix)</span></span><br><span class="line"><span class="comment">//将一个集合中的元素，使用前缀，后缀，分隔符拼装一个字符串，前缀后后缀是针对每一个字符串的</span></span><br><span class="line">String[] arrs=<span class="keyword">new</span> String[]&#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>&#125;;</span><br><span class="line">assertEquals(<span class="string">"&#123;aa&#125;,&#123;bb&#125;,&#123;cc&#125;,&#123;dd&#125;"</span>, StringUtils.collectionToDelimitedString(Arrays.asList(arrs),<span class="string">","</span>,<span class="string">"&#123;"</span>,<span class="string">"&#125;"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//String collectionToDelimitedString(Collection&lt;?&gt; coll, String delim)：集合变成指定字符串连接的字符串；</span></span><br><span class="line"><span class="comment">//是collectionToDelimitedString(coll, delim, "", "")的简写；</span></span><br><span class="line"><span class="comment">//String collectionToCommaDelimitedString(Collection&lt;?&gt; coll)：集合变成逗号连接的字符串；</span></span><br><span class="line"><span class="comment">//是collectionToDelimitedString(coll, ",");的简写；</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//String arrayToDelimitedString(Object[] arr, String delim)：数组使用指定字符串连接；</span></span><br><span class="line"><span class="comment">//String arrayToCommaDelimitedString(Object[] arr)：使用逗号连接数组，拼成字符串；</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring系列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(CentOS7)下Docker的安装与卸载</title>
    <url>/Linux/Linux-CentOS7-%E4%B8%8BDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html</url>
    <content><![CDATA[<p>官方地址</p>
<p>英文：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p>
<p>中文：<a href="https://docs.docker-cn.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/installation/</a></p>
<h2 id="确定你是CentOS7版本"><a href="#确定你是CentOS7版本" class="headerlink" title="确定你是CentOS7版本"></a>确定你是CentOS7版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301645_330.png" alt=""></p>
<h2 id="yum安装gcc相关"><a href="#yum安装gcc相关" class="headerlink" title="yum安装gcc相关"></a>yum安装gcc相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
<h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><p>此卸载和安装完成后的卸载有些不一样。防止出现错误，最好在安装前卸载旧版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<h2 id="使用存储库安装"><a href="#使用存储库安装" class="headerlink" title="使用存储库安装"></a>使用存储库安装</h2><h3 id="安装所需的包"><a href="#安装所需的包" class="headerlink" title="安装所需的包"></a>安装所需的包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<h3 id="设置稳定存储库"><a href="#设置稳定存储库" class="headerlink" title="设置稳定存储库"></a>设置<strong>稳定</strong>存储库</h3><p>这步很关键</p>
<p>官网命令是（<strong>大坑</strong>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  #不推荐使用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官网用的是外国的地址，由于我们伟大墙的原因，有时会不稳定，所以建议将其改为国内地址。如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  #推荐使用</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301702_658.png" alt=""></p>
<h2 id="更新yum软件包索引"><a href="#更新yum软件包索引" class="headerlink" title="更新yum软件包索引"></a>更新yum软件包索引</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301753_868.png" alt=""></p>
<h2 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker  CE"></a>安装Docker  CE</h2><h3 id="安装最新版"><a href="#安装最新版" class="headerlink" title="安装最新版"></a>安装最新版</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301759_704.png" alt=""></p>
<blockquote>
<p>返回的列表取决于启用的存储库，并且特定于您的CentOS版本（<code>.el7</code>在此示例中以后缀表示）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>sudo yum install docker-ce-&lt;VERSION STRING&gt;</span><br><span class="line">sudo yum install docker-ce-18.03.0.ce</span><br></pre></td></tr></table></figure>
<h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">docker version   #检查docker版本</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301807_307.png" alt=""></p>
<h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><p>安装完成之后，默认下载镜像的仓库是国外的，又因为我们伟大的墙，所以我们配置国内的镜像加速。推荐阿里云和网易加速。这里以阿里云为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://xxxx.mirror.aliyuncs.com"]  #xxxx此处需要登录自己的阿里云查找</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>阿里云镜像加速地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/mirrors</a></p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">sudo yum remove docker-ce</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云Linux下安装MySql5.6、5.7、8.0版本和卸载以及远程连接</title>
    <url>/Linux/%E9%98%BF%E9%87%8C%E4%BA%91Linux%E4%B8%8B%E5%AE%89%E8%A3%85MySql5-6%E3%80%815-7%E3%80%818-0%E7%89%88%E6%9C%AC%E5%92%8C%E5%8D%B8%E8%BD%BD%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html</url>
    <content><![CDATA[<p>在安装的时候参考了很多博客，但是发现还是 MySql的官网给的步骤最有效，最权威。</p>
<p>官方地址：<a href="https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/</a></p>
<p>Debian 7,8,9</p>
<p>Ubuntu 14.04,16.04,17.10,18.04</p>
<p>下面记录下我安装的步骤：</p>
<h2 id="添加-MySQL-APT存储库"><a href="#添加-MySQL-APT存储库" class="headerlink" title="添加 MySQL APT存储库"></a>添加 MySQL APT存储库</h2><p>首先我们需要下载 MySQL APT 存储库， MySQL APT 存储库提供了一种使用Apt 最新软件包安装和更新MySQL 产品的简单方便的方法。</p>
<p>这里我用的是 0.8.10_1 版本，可能随找时间的变化，版本会不同，查看版本的地址：</p>
<p><a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/apt/</a></p>
<p><img src="http://qiniu.mrain22.cn/201811301528_47.png" alt=""></p>
<p>命令下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wget -P /root/Downloads http://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb</span><br></pre></td></tr></table></figure>
<h2 id="安装发布包"><a href="#安装发布包" class="headerlink" title="安装发布包"></a>安装发布包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i /root/Downloads/mysql-apt-config_0.8.10-1_all.deb  #注意路径和版本号要与下载时的一致。</span><br></pre></td></tr></table></figure>
<p>然后会弹出窗口，需要选择版本的就好<br>首先，我们用上下键，选择第一个，按回车键 </p>
<p><img src="http://qiniu.mrain22.cn/201811301532_941.png" alt=""></p>
<p>然后，再选择你想安装的版本</p>
<p><img src="http://qiniu.mrain22.cn/201811301533_948.png" alt=""></p>
<p>然后选择 OK</p>
<p><img src="http://qiniu.mrain22.cn/201811301534_535.png" alt=""></p>
<h2 id="执行apt-get-update"><a href="#执行apt-get-update" class="headerlink" title="执行apt-get update"></a>执行apt-get update</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>这句是必须执行的，如果不执行，那么刚才的操作相当于没做。</p>
<h2 id="使用APT安装MySQL"><a href="#使用APT安装MySQL" class="headerlink" title="使用APT安装MySQL"></a>使用APT安装MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p>这将安装的MySQL 服务器的包，以及客户端和数据库公共文件的包。</p>
<p>安装的过程会问你 “ 是”或“ 否”，自然是选择“ 是”。</p>
<p>在安装过程中，系统会要求您为根用户提供的MySQL 安装的密码。</p>
<p><img src="http://qiniu.mrain22.cn/201811301536_836.png" alt=""></p>
<h2 id="启动和停止的MySQL的服务器"><a href="#启动和停止的MySQL的服务器" class="headerlink" title="启动和停止的MySQL的服务器"></a>启动和停止的MySQL的服务器</h2><p>MySQL服务器在安装后自动启动。您可以使用以下命令检查MySQL服务器的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysql status</span><br></pre></td></tr></table></figure>
<p>使用以下命令停止MySQL服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure>
<p>要重新启动MySQL服务器，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure>
<h2 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h2><p>我们可以通过以下语句登录MySql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>然后输入刚才安装时输入的密码即可登录成功。</p>
<h2 id="建立远程连接"><a href="#建立远程连接" class="headerlink" title="建立远程连接"></a>建立远程连接</h2><p>在云服务上安装MySQL后我们可以通过以下设置来通过本地连接服务器上的MySQL。</p>
<h3 id="授权主机访问"><a href="#授权主机访问" class="headerlink" title="授权主机访问"></a>授权主机访问</h3><p>在登录进mysql后，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;你的密码&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301540_200.png" alt=""></p>
<p>在“你的密码”处，填写你自己的密码。回车。</p>
<p>刷新权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL&gt;FLUSH PRIVILEGES;    回车</span><br></pre></td></tr></table></figure>
<p>退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL&gt;EXIT;    回车</span><br></pre></td></tr></table></figure>
<h3 id="修改MySQL配置"><a href="#修改MySQL配置" class="headerlink" title="修改MySQL配置"></a>修改MySQL配置</h3><p>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi  /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.mrain22.cn/201811301554_427.png" alt=""></p>
<p>将红色标注的地方注释掉（前面加#，图中我已经注释掉）</p>
<p>按ESC 输入  ：wq! 回车保存。</p>
<p>重启mysql。</p>
<h3 id="在阿里云服务器安全组规则中打开3306端口"><a href="#在阿里云服务器安全组规则中打开3306端口" class="headerlink" title="在阿里云服务器安全组规则中打开3306端口"></a>在阿里云服务器安全组规则中打开3306端口</h3><p>登录阿里云，找到服务器的安全组规则，添加安全组规则。</p>
<p><img src="http://qiniu.mrain22.cn/201811301555_568.png" alt=""></p>
<p>这样就可以通过本地连接服务器上的MySQL的了</p>
<h2 id="卸载MySQL"><a href="#卸载MySQL" class="headerlink" title="卸载MySQL"></a>卸载MySQL</h2><p>先输入指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove mysql-server</span><br></pre></td></tr></table></figure>
<p>待指令执行完毕再输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure>
<p>然后清理残留的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep ^rc|awk '&#123;print $2&#125;' |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure>
<p>它会跳出一个对话框，你选择yes就好了。</p>
<p>这样就彻底卸载了MySql了，想要安装的话，按照第一步重新安装。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 运行机制Event Loop（浏览器与node环境的不同）</title>
    <url>/JavaScript/JavaScript-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6Event-Loop%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Enode%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<ul>
<li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li>
<li>异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li>
</ul>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<blockquote>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
</blockquote>
<p><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。但是浏览器的Event loop和Node的Event loop是两个概念。</strong></p>
<p>在JavaScript中，“任务队列”任务队列被分为MacroTask（宏任务）和MicroTask（微任务）两种。它们分别包含以下内容：</p>
<ul>
<li><p><strong>MacroTask</strong>: script(整体代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering</p>
</li>
<li><p><strong>MicroTask</strong>: process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver</p>
</li>
</ul>
<h2 id="浏览器中"><a href="#浏览器中" class="headerlink" title="浏览器中"></a>浏览器中</h2><p>在浏览器中”执行栈”中的所有同步任务执行完毕，去“任务队列”找要执行的任务，首先找MicroTask（微任务）队列中是否有要执行的任务，有则<strong>全部执行</strong>，然后再找MacroTask（宏任务）队列中是否有要执行的任务，如果有则执行MacroTask（宏任务）队列的<strong>第一个</strong>，再去执行MicroTask（微任务）队列中的<strong>所有</strong>微任务。</p>
<blockquote>
<p>同步代码—&gt;MicroTask—&gt;MacroTask</p>
</blockquote>
<p>每执行完一个Macrotask都会检查Microtask队列是否为空（执行完一个Macrotask的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有Microtask。然后再进入下一个循环去MacroTask（宏任务）队列中取下一个MacroTask（宏任务）执行，以此类推。</p>
<p><img src="http://qiniu.mrain22.cn/201811301501_536.png" alt=""></p>
<ul>
<li>代码 1.1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">开始</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">timer1</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">timer2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>解析：</strong></p>
<p>1、首先主线程的执行栈开始工作，从上到下执行，输出“1、开始”，遇到第一个setTimeout，将其推到“任务队列”的“宏任务”队列中。遇到第二个setTimeout，也将其推到“任务队列”的“宏任务”队列中排在第二位。遇到Promise，将其推到“任务队列”的“微任务”队列中。至此主线程执行完毕，去“任务队列”找任务。</p>
<p>2、“任务队列”中“微任务”队列中有任务，先执行，输出“2、promise1”。微任务”队列中所有任务执行完，再去找“宏任务”队列。</p>
<p>3、执行“宏任务”队列的第一个任务（第一个setTimeout），输出“3、timer1”，将Promise推到“微任务”队列。执行完一个“宏任务”，执行所有“微任务”，输出“4、promise2”。</p>
<p>4、执行完所有“微任务后”，再去检查“宏任务”，执行第二个setTimeout，输出“5、timer2”。全部任务结束。</p>
</blockquote>
<h2 id="Node环境中"><a href="#Node环境中" class="headerlink" title="Node环境中"></a>Node环境中</h2><p>nodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下：</p>
<p><img src="http://qiniu.mrain22.cn/201811301504_417.png" alt=""></p>
<blockquote>
<ol>
<li>timers：执行setTimeout() 和 setInterval()中到期的callback。</li>
<li>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</li>
<li>idle, prepare：队列的移动，仅内部使用</li>
<li>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li>
<li>check：执行setImmediate的callback</li>
<li>close callbacks：执行close事件的callback，例如socket.on(“close”,func)</li>
</ol>
</blockquote>
<p>不同于浏览器的是，在<strong>每个阶段完成所有阶段任务后</strong>（而不是MacroTask任务完成后，每个阶段可能会有好多任务，可以把6个阶段看做宏任务（MacroTask）的排序）microTask队列中的所有任务就会被执行。这就导致了同样的代码在不同的上下文环境下会出现不同的结果。</p>
<p><img src="http://qiniu.mrain22.cn/201811301508_15.png" alt=""></p>
<p>如上面代码1.1，在node环境下运行结果为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">开始</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">timer1</span></span><br><span class="line"><span class="comment">timer2</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>解析：</strong></p>
<p>1、首先主线程的执行栈开始工作，从上到下执行，输出“1、开始”，遇到第一个setTimeout，将其推到“任务队列”的“timer阶段”队列中。遇到第二个setTimeout，也将其推到“任务队列”的“timer阶段”队列中排在第二位。遇到Promise，将其推到“任务队列”的“微任务”队列中。至此主线程执行完毕，去“任务队列”找任务。</p>
<p>2、“任务队列”中“微任务”队列中有任务，先执行，输出“2、promise1”。微任务”队列中所有任务执行完，再去找“timer阶段”队列。</p>
<p>3、执行“timer阶段”队列的第一个任务（第一个setTimeout），输出“3、timer1”，将Promise推到“微任务”队列。执行“timer阶段”队列的第二个任务（即第二个setTimeout），输出“4、timer2”。至此“timer阶段”的所有任务执行完毕。</p>
<p>4、执行“微任务”队列的任务，输出“5、promise2”全部任务结束。</p>
</blockquote>
<ul>
<li>代码1.2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line"></span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'我是setTimeout内部的process.nextTick'</span>);</span><br><span class="line">       </span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'内部setImmediate'</span>);</span><br><span class="line">       </span><br><span class="line">   &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'我是外部的process.nextTick'</span>);</span><br><span class="line">   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line"></span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'我是setImmediate内部的process.nextTick'</span>);</span><br><span class="line">       </span><br><span class="line">   &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">开始</span></span><br><span class="line"><span class="comment">我是外部的process.nextTick</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">我是setTimeout内部的process.nextTick</span></span><br><span class="line"><span class="comment">setImmediate</span></span><br><span class="line"><span class="comment">内部setImmediate</span></span><br><span class="line"><span class="comment">我是setImmediate内部的process.nextTick</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>解析：</strong></p>
<p>（1） 先执行同步 输出“1、开始”，将setTimeout推到timer阶段的队列中，将process.nextTick推到micro-task(微任务)，将setImmediate推到check 阶段的队列中<strong>。</strong></p>
<p>（2） 同步执行完毕，执行micro-task，执行process.nextTick，输出“<strong>2、</strong>我是外部的process.nextTick”，此时微服务队列中没有任务了。</p>
<p>（3）按6个阶段顺序执行，执行timer阶段队列中的任务，此时队列中只有setTimeout一个任务执行，输出“3、setTimeout”，将其内部的process.nextTick推送到micro-task(微任务)队列中，将其内部的setImmediate推送到check阶段的队列中（注意：此时check队列中有两个任务，一个是外部的setImmediate，一个是内部的setImmediate）。setTimeout（timer阶段）执行完毕，执行micro-task(微任务)队列，输出“4、我是setTimeout内部的process.nextTick”。micro-task(微任务)队列执行完毕。</p>
<p>（4）进入下一个阶段，由于没有i/o读写等操作，直接到check阶段，执行check阶段队列中的任务，执行外部的setImmediate，输出“5、setImmediate”，并将其内部的process.nextTick推送到micro-task(微任务)队列中，执行check阶段队列中的第二个任务setImmediate（内部的setImmediate），输出“6、内部的setImmediate”。check阶段队列中没有任务了，执行micro-task(微任务)队列中的任务，输出“7、我是setImmediate内部的process.nextTick”</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>同一个上下文下，MicroTask会比MacroTask先运行</li>
<li>然后浏览器按照一个MacroTask任务，所有MicroTask的顺序运行，Node按照六个阶段的顺序运行，并在每个阶段后面都会运行MicroTask队列</li>
<li>同个MicroTask队列下<code>process.tick()</code>会优于<code>Promise</code></li>
</ol>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上仅是我个人在学习过程中总结的自己的认识，难免会有错误，有任何问题还望不吝指出。</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">《JavaScript 运行机制详解：再谈Event Loop》—–阮一峰</a></li>
<li><a href="https://funteas.com/topic/5ac0343e60897ba7206a9ce8" target="_blank" rel="noopener">《一篇文章教会你Event loop——浏览器和Node》</a></li>
<li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">《这一次，彻底弄懂 JavaScript 执行机制》</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
